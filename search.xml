<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA_OS_2023_Lab0</title>
      <link href="/2023/03/22/buaa-os-2023-lab0/"/>
      <url>/2023/03/22/buaa-os-2023-lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab0-实验报告"><a href="#Lab0-实验报告" class="headerlink" title="Lab0 实验报告"></a>Lab0 实验报告</h1><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>在前述已初始化的 <code>~/learnGit</code> 目录下，创建一个名为 <code>README.txt</code> 的文件，执行命令 <code>git status &gt; Untracked.txt</code> 后，<code>Untracked.txt</code> 文件的内容为：</p><pre class="line-numbers language-none"><code class="language-none">位于分支 master尚无提交未跟踪的文件:  （使用 "git add &lt;文件&gt;..." 以包含要提交的内容）        README.txt        Untracked.txt提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>README.txt</code> 文件中添加一行内容 <code>HELLO WORLD!</code> ，然后执行 <code> git add README.txt</code>  命令，再执行命令 <code>git status &gt; Stage.txt</code> ， <code>Stage.txt</code> 文件的内容为：</p><pre class="line-numbers language-none"><code class="language-none">位于分支 master尚无提交要提交的变更：  （使用 "git rm --cached &lt;文件&gt;..." 以取消暂存）        新文件：   README.txt未跟踪的文件:  （使用 "git add &lt;文件&gt;..." 以包含要提交的内容）        Stage.txt        Untracked.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现经过 <code>add</code> 命令， <code>README.txt</code> 文件从“未跟踪的文件”移至了“要提交的变更”，即由 Untracked 变为 Staged 。</p><p>执行命令 <code>git commit -m "21373311 README.txt"</code> ，发现 <code>README.txt</code> 文件已从 Staged 区移除。</p><p>在 <code>README.txt</code> 文件后添加一行内容 <code>HELLO OS!</code> ，再执行命令 <code>git status &gt; Modified.txt</code> ， <code>Modified.txt</code> 文件的内容为：</p><pre class="line-numbers language-none"><code class="language-none">位于分支 master尚未暂存以备提交的变更：  （使用 "git add &lt;文件&gt;..." 更新要提交的内容）  （使用 "git restore &lt;文件&gt;..." 丢弃工作区的改动）        修改：     README.txt未跟踪的文件:  （使用 "git add &lt;文件&gt;..." 以包含要提交的内容）        Modified.txt        Stage.txt        Untracked.txt修改尚未加入提交（使用 "git add" 和/或 "git commit -a"）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和第一次执行 <code>add</code> 命令之前的 status 相比， <code>README.txt</code> 文件的位置不再是“未跟踪的文件”，而是“尚未暂存以备提交的变更“。原因是经过 <code>add</code> 命令后， <code>README.txt</code> 已被添加至 Git 的暂存区， Git 会跟踪该文件的变化，所以之后该文件若又被修改，则会出现在已修改部分而不是未跟踪部分。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><p>仔细看看0.10，思考一下箭头中的 <code>add the file</code> 、<code>stage the file</code> 和<br><code>commit</code> 分别对应的是 Git 里的哪些命令呢？</p><p><img src="/2023/03/22/buaa-os-2023-lab0/study\OS\实验报告\lab0\图0.10.png" alt="图0.10"></p><ul><li>add the file: 对应 <code>git add [filename]</code> 命令</li><li>stage the file: 对应 <code>git add [filename]</code> 命令</li><li>commit: 对应 <code>git commit</code> 命令</li></ul><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><ol><li><p>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</p><ul><li><code>git checkout -- print.c</code></li></ul></li><li><p>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当<br>使用什么命令将其恢复？</p><ul><li><code>git reset HEAD print.c</code></li><li><code>git checkout -- print.c</code></li></ul></li><li><p>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下<br>将其移出暂存区？</p><ul><li><code>git rm --cached hello.txt</code></li></ul></li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>找到在 <code>/home/21xxxxxx/learnGit</code> 下刚刚创建的 <code>README.txt</code> 文件，在文件里加入 Testing 1，git add，git commit，提交说明记为 1 。</p><p>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</p><p>进行版本回退。执行命令 <code>git reset --hard HEAD^</code> 后，再执行 <code>git log</code> ，观<br>察其变化，发现<strong>哈希值为 3 的提交已经消失</strong>。</p><p>找到提交说明为 1 的哈希值，执行命令 <code>git reset --hard &lt;hash&gt;</code> 后，再执<br>行 <code>git log</code> ，观察其变化，发现 <strong>3 次提交均已消失</strong>。</p><p>现在已经回到了旧版本，为了再次回到新版本，执行 <code>git reset --hard &lt;hash&gt;</code> ，再执行 <code>git log</code> ，观察其变化，发现 <strong>3 次提交再次出现</strong>。</p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><p>执行如下命令, 并查看结果</p><ol><li><p>echo first</p><p>输出 first</p></li><li><p>echo second &gt; output.txt</p><p>将文件 <code>output.txt</code> 内容改写为:</p><pre class="line-numbers language-none"><code class="language-none">second<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>echo third &gt; output.txt</p><p>​将文件 <code>output.txt</code> 内容改写为:</p><pre class="line-numbers language-none"><code class="language-none">third<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>echo forth &gt;&gt; output.txt</p><p>将文件 <code>output.txt</code> 内容改写为:</p><pre class="line-numbers language-none"><code class="language-none">thirdforth<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手）。具体实现的过程中思考下列问题: </p><p>echo echo Shell Start 与 echo `echo Shell Start`效果是否有区别; </p><p>echo echo$c&gt;file1 与 echo `echo $c&gt;file1`效果是否有区别. </p><p><img src="/2023/03/22/buaa-os-2023-lab0/study\OS\实验报告\lab0\图0.14.png" alt="图0.14"></p><ul><li><p>command 文件内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> Shell Start<span class="token punctuation">..</span>. <span class="token operator">&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> b <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> c <span class="token operator">=</span> a+b <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token punctuation">\</span>$<span class="token punctuation">[</span><span class="token punctuation">\</span><span class="token variable">$a</span>+<span class="token punctuation">\</span><span class="token variable">$b</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token assign-left variable">c</span><span class="token operator">=</span> <span class="token punctuation">\</span><span class="token variable">$c</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save c to ./file1 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $c&gt;file1'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save b to ./file2 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $b&gt;file2'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save a to ./file3 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'echo $a&gt;file3'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save file1 file2 file3 to file4 <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file1&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file2&gt;&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file3&gt;&gt;file4'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> save file4 to ./result <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">'cat file4&gt;&gt;result'</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin class-name">test</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>result 文件内容：</p><pre class="line-numbers language-none"><code class="language-none">321<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>下面根据 test 文件内容说明出现该结果的原因：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> Shell Start<span class="token punctuation">..</span>. <span class="token comment">#输出 Shell Start...</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token comment">#输出 set a = q</span><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span><span class="token comment">#给变量 a 赋值 1</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token comment">#输出 set b = 2</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">2</span><span class="token comment">#给变量 b 赋值 2</span><span class="token builtin class-name">echo</span> <span class="token builtin class-name">set</span> c <span class="token operator">=</span> a+b<span class="token comment">#输出 set c = a+b</span><span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span><span class="token variable">$a</span>+<span class="token variable">$b</span><span class="token punctuation">]</span><span class="token comment">#给变量 c 赋值 (a+b)</span><span class="token builtin class-name">echo</span> <span class="token assign-left variable">c</span><span class="token operator">=</span> <span class="token variable">$c</span><span class="token comment">#输出 c= $c</span><span class="token builtin class-name">echo</span> save c to ./file1<span class="token comment">#输出 save c to ./file1</span><span class="token builtin class-name">echo</span> <span class="token variable">$c</span><span class="token operator">&gt;</span>file1<span class="token comment">#把变量 c 的值输出到文件 file1</span><span class="token builtin class-name">echo</span> save b to ./file2<span class="token comment">#输出 save b to ./file2</span><span class="token builtin class-name">echo</span> <span class="token variable">$b</span><span class="token operator">&gt;</span>file2<span class="token comment">#把变量 b 的值输出到文件 file2</span><span class="token builtin class-name">echo</span> save a to ./file3<span class="token comment">#输出 save a to ./file3</span><span class="token builtin class-name">echo</span> <span class="token variable">$a</span><span class="token operator">&gt;</span>file3 <span class="token comment">#把变量 a 的值输出到文件 file3</span><span class="token builtin class-name">echo</span> save file1 file2 file3 to file4 <span class="token comment">#输出 save file1 file2 file3 to file4 </span><span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>file4 <span class="token comment">#将 file4 改写为 file1 的内容</span><span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">2</span>&gt;&gt;</span>file4 <span class="token comment">#在 file4 后添加 file2 的内容</span><span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">3</span>&gt;&gt;</span>file4 <span class="token comment">#在 file4 后添加 file3 的内容</span><span class="token builtin class-name">echo</span> save file4 to ./result <span class="token comment">#输出 save file4 to ./result </span><span class="token function">cat</span> file<span class="token operator"><span class="token file-descriptor important">4</span>&gt;&gt;</span>result <span class="token comment">#在 result 后添加 file4 的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>echo echo Shell Start 与 echo `echo Shell Start`效果是否有区别？<ul><li>没有区别，都是输出字符串 echo Shell Start</li></ul></li><li>echo echo$c&gt;file1 与 echo `echo $c&gt;file1`效果是否有区别？<ul><li>有区别，前者是用字符串 echo$c 写 file1，后者是输出字符串 echo $c&gt;file1</li></ul></li></ul><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><ol><li><p>对 <code>sed</code> 命令各个参数的熟练运用</p><p>在 Exercise 0.1-3 中，要求提取 AAA 文件的第 8、32、128、512、1024 行的内容，并输入到文件 BBB 中，需要用到的 bash 文件为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> <span class="token variable">$2</span><span class="token keyword">for</span> <span class="token for-or-select variable">line</span> <span class="token keyword">in</span> <span class="token number">8</span> <span class="token number">32</span> <span class="token number">128</span> <span class="token number">512</span> <span class="token number">1024</span> <span class="token builtin class-name">:</span><span class="token keyword">do</span><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token variable">${line}</span>p"</span> <span class="token variable">$1</span> <span class="token operator">&gt;&gt;</span> <span class="token variable">$2</span><span class="token keyword">done</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 $1 是待读取文件 AAA ，$2 是待写入文件 BBB。</p></li><li><p>Makefile 文件内部使用其他目录的 Makefile 文件</p><p>在 Exercise 0.4-2 中，不同的 2 个目录下均有 Makefile 文件，在 csc/ 目录下的 Makefile 文件需使用到 csc/code/ 目录下的 Makefile 文件。要注意的是：</p><ol><li>在 Makefile 文件内需要使用相对路径来书写文件名等。</li><li>可以在 Makefile 文件内通过 <code>cd</code> 命令来进入其他目录并执行其他目录的 Makefile 文件。</li></ol></li><li><p><code>gcc</code> 命令 <code>-c</code> 参数的意义</p><p>在使用 <code>gcc</code> 命令时，<code>-c</code> 参数指示编译器仅仅进行编译和汇编，并生成目标文件，而不进行链接操作。在 Exercise 0.4-2 中，main.c 文件调用了 fibo.c ，我在第一次编写指令时未添加 <code>-c</code> 参数，导致编译失败，应该先使用 <code>-c</code> 参数生成 2 个未进行链接的 .o 文件，再将两个 .o 文件使用不带 <code>-c</code> 参数的 <code>gcc</code> 命令进行链接。</p></li></ol><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>在 Lab0 课下实验中，我初步了解了 Linux 操作系统的命令行界面，学习到了一些基础指令的使用。其中，我对 Shell 脚本很感兴趣，这和我之前接触得更多的图形界面不同，它是一个命令的集合，是一种文本性的描述，实现了效率很高的精准自动化操作。我觉得学习自主编写 Shell 脚本并运行得到特定结果会是一件并不简单但很有乐趣的过程。另外，在上学期 cpp 课程初步了解 git 的基础上，我了解了 git 更深层的原理，也学到了更多的 git 指令。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_2023_Lab1</title>
      <link href="/2023/03/22/buaa-os-2023-lab1/"/>
      <url>/2023/03/22/buaa-os-2023-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1-实验报告"><a href="#Lab1-实验报告" class="headerlink" title="Lab1 实验报告"></a>Lab1 实验报告</h1><hr><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><p><em>请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（ <code>gcc</code> 、<code>ld</code> 、 <code>readelf</code> 、 <code>objdump</code> 等）和 MIPS 交叉编译工具链（带有 <code>mips-linux-gnu-</code> 前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 <code>objdump</code> 传入的参数的含义。</em></p><p>以文件 <code>helloworld.c</code> 为例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别使用实验环境下原生的 x86 工具链和 MIPS 交叉编译工具链操作后，其产生的预处理文件有所不同，产生的反汇编文件的<strong>指令集、位数、存储顺序、地址空间等</strong>有所不同。</p><p> <code>objdump</code> 命令的 <code>-D</code> 选项是指<strong>将文件中的可执行代码以汇编指令的形式进行反汇编，并显示出来</strong>。而 <code>-S</code> 选项是指<strong>同时显示反汇编代码和源代码之间的对应关系</strong>。</p><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><ul><li><p><em>尝试使用我们编写的 <code>readelf</code> 程序，解析之前在 <code>target</code> 目录下生成的内核 ELF 文件。</em></p></li><li><p><em>也许你会发现我们编写的 <code>readelf</code> 程序是不能解析 <code>readelf</code> 文件本身的，而我们刚才介绍的系统工具 <code>readelf</code> 则可以解析，这是为什么呢？（提示：尝试使用 <code>readelf -h</code> ，并阅读 <code>tools/readelf</code> 目录下的 <code>Makefile</code> ，观察 <code>readelf</code> 与 <code>hello</code> 的不同）</em></p></li></ul><p>执行命令 <code>$ readelf -h hello</code> 后，得到信息如下：</p><pre class="line-numbers language-none"><code class="language-none">ELF 头：  Magic：   7f 45 4c 46 01 01 01 03 00 00 00 00 00 00 00 00   类别:                              ELF32  数据:                              2 补码，小端序 (little endian)  Version:                           1 (current)  OS/ABI:                            UNIX - GNU  ABI 版本:                          0  类型:                              EXEC (可执行文件)  系统架构:                          Intel 80386  版本:                              0x1  入口点地址：               0x8049600  程序头起点：          52 (bytes into file)  Start of section headers:          746252 (bytes into file)  标志：             0x0  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Number of program headers:         8  Size of section headers:           40 (bytes)  Number of section headers:         35  Section header string table index: 34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令 <code>$ readelf -h readelf</code> 后，得到信息如下：</p><pre class="line-numbers language-none"><code class="language-none">ELF 头：  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00   类别:                              ELF64  数据:                              2 补码，小端序 (little endian)  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI 版本:                          0  类型:                              DYN (Position-Independent Executable file)  系统架构:                          Advanced Micro Devices X86-64  版本:                              0x1  入口点地址：               0x1180  程序头起点：          64 (bytes into file)  Start of section headers:          14488 (bytes into file)  标志：             0x0  Size of this header:               64 (bytes)  Size of program headers:           56 (bytes)  Number of program headers:         13  Size of section headers:           64 (bytes)  Number of section headers:         31  Section header string table index: 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现文件 <code>hello</code> 是 32 位的，而文件 <code>readelf</code> 是 64 位的。我们编写的 <code>readelf</code> 只能解析 32 位的 ELF 文件。</p><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p><em>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 <code>0xBFC00000</code> （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。）</em></p><p>根据补充知识“真实操作系统的内核及启动详解”内容，启动的基本步骤如下图所示：</p><img src="/2023/03/22/buaa-os-2023-lab1/%E5%90%AF%E5%8A%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4.png" class="" title="启动的基本步骤"><p>基本分为 stage1 和 stage2 两个部分， stage1 会在非易失存储器（如 ROM 或 FLASH ）上执行，进行基本的硬件设备初始化，为 stage2 准备 RAM 空间，然后将 stage2 代码复制到 RAM 空间，并设置堆栈，最后跳转到 stage2 的入口函数。 stage2 运行在 RAM 中，负责初始化这一阶段需要使用的硬件设备以及其他功能，然后将内核镜像从存储器读到 RAM 中，并为内核设置启动参数，最后将 CPU 指令寄存器的内容设置为内核入口函数的地址，即可将控制权从 bootloader 转交给操作系统内核。也就是说，<strong>只要在 stage2 的代码中能够正确设置内核入口地址，即可保证内核入口被正确跳转到</strong>。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p>本次实验的难点不在于 Exercise 中代码的填写，而是对指导书内容的理解和运用。特别是理解<strong>操作系统的启动过程</strong>，以及 <strong>ELF 文件的结构和功能</strong>。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><ol><li>感觉自己对 C 语言<strong>指针</strong>的利用以及 MIPS 汇编语言有些生疏了，需要通过多读代码、理解代码来恢复一下；</li><li>之前的学习中并没有遇到需要大量<strong>读代码</strong>的任务，在操作系统课程中逐渐体会到读代码也是相当重要的学习过程。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_2023_Unit1</title>
      <link href="/2023/03/22/buaa-oo-2023-unit1/"/>
      <url>/2023/03/22/buaa-oo-2023-unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OO-Unit1-表达式解析-总结"><a href="#BUAA-OO-Unit1-表达式解析-总结" class="headerlink" title="BUAA OO Unit1 表达式解析 总结"></a>BUAA OO Unit1 表达式解析 总结</h1><hr><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="训练目标"><a href="#训练目标" class="headerlink" title="训练目标"></a>训练目标</h3><p>通过对表达式结构进行建模，完成<strong>多变量多项式的括号展开</strong>，初步体会层次化设计的思想。</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h4><p>在上学期的<a href="http://oo.buaa.edu.cn/assignment/393/intro">先导课第七次作业</a>中，已经学习并使用过<strong>递归下降法</strong>进行语法解析。通过<a href="https://mp.weixin.qq.com/s/JgyGLhOmuOJbIIn12ZM78A">OO经验贴第三弹</a>复习后，便能较为轻松地采用递归下降法对本次作业的表达式进行解析。第一次作业的文法如下：</p><ul><li>表达式 →→ 空白项 [加减 空白项] 项 空白项 | 表达式 加减 空白项 项 空白项</li><li>项 →→ [加减 空白项] 因子 | 项 空白项 ‘*’ 空白项 因子</li><li>因子 →→ 变量因子 | 常数因子 | 表达式因子</li><li>变量因子 →→ 幂函数</li><li>常数因子 →→ 带符号的整数</li><li>表达式因子 →→ ‘(‘ 表达式 ‘)’ [空白项 指数]</li><li>幂函数 →→ (‘x’ | ‘y’ | ‘z’) [空白项 指数]</li><li>指数 →→  ‘**‘ 空白项 [‘+’] 允许前导零的整数  <strong>(注：指数一定不是负数)</strong></li><li>带符号的整数 →→ [加减] 允许前导零的整数</li><li>允许前导零的整数 →→ (‘0’|’1’|’2’|…|’9’){‘0’|’1’|’2’|…|’9’}</li><li>空白项 →→ {空白字符}</li><li>空白字符 →→ (空格) | ‘\t’</li><li>加减 →→ ‘+’ | ‘-‘</li></ul><p>根据文法，我们输入的是一个<strong>表达式</strong>，这个<strong>表达式</strong>由若干个<strong>项</strong>通过 ‘+’ 或 ‘-’ 连接而成，而每个<strong>项</strong>由若干个<strong>因子</strong>通过 ‘*’ 连接而成。</p><p>因此，我们建立一个 Expr 类来储存<strong>表达式</strong>，其含有一个属性是项的列表 <code>ArrayList&lt;Term&gt; terms</code> ；建立一个 Term 类来储存<strong>项</strong>，其含有一个属性是因子的列表 <code>ArrayList&lt;Factor&gt; factors</code> 。接着，我们来考虑<strong>因子</strong>，这里的<strong>因子</strong>可能是：</p><ol><li>变量因子</li><li>常数因子</li><li>表达式因子</li></ol><p>在思考如何处理因子之前，需要思考另一个问题：<strong>如何处理符号？</strong>根据文法，表达式前可以有一个符号来表示第一个项的正负，项前可以有一个符号来表示第一个因子的正负，而常数因子，即带符号的整数可能自带一个符号。也就是说，输入的表达式中可能会有最多3个符号连续出现的情况。这时，我采用的处理符号的方法是：<strong>把所有连续出现的正负号都化为单个正负号，且该正负号代表其后因子的符号</strong>。也就是说，<strong>表达式和项都是没有正负的，只有因子有正负之分</strong>。</p><p>想清楚这个问题，就能接着处理<strong>因子</strong>了，我们建立一个 Factor 类来储存所有的因子，根据我们对正负号的处理方式，所有的因子都自带一个正负号，那么 Factor 类就有一个属性是表示正负的 <code>boolean isPos</code> 。在此基础上，我们为每个因子建一个类来进行存储，它们都继承自 Factor 类：</p><ol><li>变量因子： Var 类， 其含有一个属性是变量名 <code>String var</code> (仅可能是x/y/z)</li><li>常数因子： Number 类，其含有一个属性是数值 <code>BigInteger num</code> </li><li>表达式因子： Expr 类(已经建立)</li></ol><p>接着，我们再考虑<strong>指数</strong>的问题。根据文法，变量因子和表达式因子后可能会有指数部分，那么我们就为此前建立的 Var 类和 Expr 类都添加一个属性 <code>int pow</code> 表示其指数。</p><p>至此，我们已经将解析表达式所需要的结构类都建立完毕，下面就可以利用<strong>递归下降法</strong>对表达式进行解析了。</p><p>使用递归下降法解析表达式，除了建立类来存储和结构化之外，还需要编写**词法解析器(Lexer)<strong>和</strong>语法解析器(Parser)**。</p><p>词法解析器基本可以直接使用<a href="https://mp.weixin.qq.com/s/JgyGLhOmuOJbIIn12ZM78A">OO经验贴第三弹</a>中的词法解析器，只需修改需要识别的合法字符即可。</p><p>语法解析器中，需要对我们之间建立的每个结构类编写一个解析的方法，在第一次作业中需要编写的是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// TODO</span>    <span class="token keyword">return</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Term</span> <span class="token function">parseTerm</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// TODO</span>    <span class="token keyword">return</span> term<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Factor</span> <span class="token function">parseFactor</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// TODO </span>        <span class="token keyword">return</span> expr<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// TODO </span>        <span class="token keyword">return</span> <span class="token keyword">var</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// TODO </span>        <span class="token keyword">return</span> number<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写完 Lexer 和 Parser 后，便可对输入的表达式进行解析，实现表达式的层次化和结构化存储。</p><h4 id="表达式的化简"><a href="#表达式的化简" class="headerlink" title="表达式的化简"></a>表达式的化简</h4><h5 id="去括号"><a href="#去括号" class="headerlink" title="去括号"></a>去括号</h5><p>完成表达式的解析后，我们再回顾第一次作业的训练目标：完成多变量多项式的括号展开。这里，括号指的就是表达式因子的括号，所以我把“括号展开”理解为<strong>将表达式因子转化为变量因子和常数因子</strong>。如此看来，括号展开应当是 Term 的方法，即需要将每个 Term 中含有的所有 Factor instanceof Expr 转化为 Var 和 Number 。那么如何进行这样的转化呢？一个括号(表达式因子)被展开，利用的原理是<strong>乘法分配律</strong>，也就是说我们需要让这个表达式因子中的<strong>每一个项</strong>和<strong>这个表达式因子所属的项的其余所有因子</strong>合并为一个<strong>新的项</strong>，这些<strong>新的项共同构成的新的表达式</strong>即为将该括号展开后的表达式。在我的代码中，我将去括号分为了降幂和乘开两个步骤，即先将需要展开的表达式因子的幂次降为1，再将每个幂次为1的表达式因子展开。</p><h5 id="合并同类项"><a href="#合并同类项" class="headerlink" title="合并同类项"></a>合并同类项</h5><p>在中强测中，性能分(唯一评判依据是<strong>输出结果的有效长度</strong>)占比20%。为了将输出的表达式尽可能缩短，我们需要进行合并同类项。</p><p>为了便于合并，我们将每个项都化简为以下形式：<br>$$<br>m x^a y^b z^c<br>$$<br>然后比较每个项的 a,b,c 值是否均相同，若相同，即可将项的系数进行合并。</p><h3 id="度量分析"><a href="#度量分析" class="headerlink" title="度量分析"></a>度量分析</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><img src="/2023/03/22/buaa-oo-2023-unit1/hw1_p.png" class="" title="hw1类图"><h4 id="代码量"><a href="#代码量" class="headerlink" title="代码量"></a>代码量</h4><img src="/2023/03/22/buaa-oo-2023-unit1/oo_unit1_hw1_statistic.png" class="" title="hw1代码量"><h4 id="类复杂度"><a href="#类复杂度" class="headerlink" title="类复杂度"></a>类复杂度</h4><img src="/2023/03/22/buaa-oo-2023-unit1/oo_unit1_hw1_classMetrics.png" class="" title="hw1类复杂度"><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在 Term 类中，实现了降幂、去括号、将项转化为标准项等方法，导致该类复杂度较高。</p><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><h4 id="自己代码中的-bug"><a href="#自己代码中的-bug" class="headerlink" title="自己代码中的 bug"></a>自己代码中的 bug</h4><p>在处理 0 次幂时，我将指数为 0 的表达式因子或变量因子都直接解析为常数变量 1 ，但由于我对符号的处理中，将所有出现的正负号都归属于其后的因子，导致一个指数为 0 的负因子被解析为 ‘+1’ 而不是 ‘-1’ 。</p><h4 id="同房其他人代码中的-bug"><a href="#同房其他人代码中的-bug" class="headerlink" title="同房其他人代码中的 bug"></a>同房其他人代码中的 bug</h4><ol><li>对 0 次幂结果为 1 的处理出现错误；</li><li>符号处理不正确，出现丢掉负号的情况。</li></ol><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="训练目标-1"><a href="#训练目标-1" class="headerlink" title="训练目标"></a>训练目标</h3><p>新增<strong>三角函数</strong>、<strong>自定义函数调用</strong>。支持<strong>括号的嵌套</strong>。</p><h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><p>新建 Trig 类来储存三角函数因子，其属性有因子 <code>Factor factor</code> 和指数 <code>Integer pow</code> 。这里的因子仍有可能是任何种类的因子。</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>在第二次作业中，新增了自定义函数的定义及其调用。在本次作业中，我采用<strong>字符串替换</strong>的方式进行函数调用<del>(在第三次作业中被迫重构)</del>，根据根据括号层数和逗号划分实参并进行字符串的替换。</p><p>首先，建立 Definition 类来储存函数的定义，其属性有函数参数 <code>String parameter</code> (参数字符串中变量名的数量和顺序表明了参数的数目与前后顺序)和函数体 <code>String body</code> 。</p><p>在储存了输入的自定义函数后，我在输入预处理的过程中对输入的表达式字符串进行处理，即对所有函数名(f/g/h)后的括号(括号范围可以通过栈来进行确定)内的内容用逗号进行分割，从而形成一个储存实参的字符串的列表，根据函数名找到对应函数的定义，然后将定义式中的形参转化为之前得到的实参即可。</p><h3 id="度量分析-1"><a href="#度量分析-1" class="headerlink" title="度量分析"></a>度量分析</h3><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><img src="/2023/03/22/buaa-oo-2023-unit1/hw2_p.png" class="" title="hw2类图"><h4 id="代码量-1"><a href="#代码量-1" class="headerlink" title="代码量"></a>代码量</h4><img src="/2023/03/22/buaa-oo-2023-unit1/oo_unit1_hw2_statistic.png" class="" title="hw2代码量"><h4 id="类复杂度-1"><a href="#类复杂度-1" class="headerlink" title="类复杂度"></a>类复杂度</h4><img src="/2023/03/22/buaa-oo-2023-unit1/oo_unit1_hw2_classMetrics.png" class="" title="hw2类复杂度"><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ol><li>除了在 hw1 中出现的 Term 类的问题之外，新增的 Trig 类也单独实现了降幂、去括号等方法，复杂度也较高；</li><li>由于在第二次作业中并未对含三角函数的项进行合并同类项处理，在 Expr 类中的合并同类项方法下新增了对含三角函数项的单独处理，导致 Expr 类的复杂度升高。</li></ol><h3 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug"></a>Bug</h3><p>本次代码在强测和互测中没有出现 bug 。</p><h4 id="同房其他人代码中的bug"><a href="#同房其他人代码中的bug" class="headerlink" title="同房其他人代码中的bug"></a>同房其他人代码中的bug</h4><p>丢掉了 -cos(0) 和 -sin(0) 的负号。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="训练目标-2"><a href="#训练目标-2" class="headerlink" title="训练目标"></a>训练目标</h3><p>新增<strong>求导因子</strong>。支持函数的嵌套调用。</p><h3 id="架构设计-2"><a href="#架构设计-2" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="处理求导算子"><a href="#处理求导算子" class="headerlink" title="处理求导算子"></a>处理求导算子</h4><p>新增的求导因子的文法如下：</p><ul><li>求导因子 →→ 求导算子 空白项 ‘(‘ 空白项 表达式 空白项 ‘)’</li><li>求导算子 →→ ‘dx’ ｜’dy’ ｜’dz’</li></ul><p>为了进行求导计算，我采用了第二次课上实验所提供的思路，<strong>为每个需要求导的结构类编写一个求导方法</strong>。据此，我在 Parser 中解析求导因子时，直接返回<strong>调用求导因子内表达式的求导方法所返回的表达式</strong>，便可在解析完成的同时完成求导计算。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Expr</span> <span class="token function">parseDerivative</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// TODO</span>    <span class="token class-name">Expr</span> expr <span class="token operator">=</span> <span class="token class-name">Simplify</span><span class="token punctuation">.</span><span class="token function">deriveExpr</span><span class="token punctuation">(</span>defs<span class="token punctuation">,</span> <span class="token function">parseExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> varName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// TODO</span>    <span class="token keyword">return</span> expr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="表达式化简"><a href="#表达式化简" class="headerlink" title="表达式化简"></a>表达式化简</h4><p>在第三次作业中，我将所有的化简方法(降幂、去括号、函数调用、求导、合并同类项)都从它们各自的结构类中分离出来，并统一写为 Simplify 类的静态方法，可以通过类名直接调用这些方法。</p><p>另外，我在第二次作业的基础上添加了简单的三角函数化简，即支持合并两个<strong>含三角函数因子数为 1 且三角函数内部因子为幂函数</strong>的项。</p><h3 id="度量分析-2"><a href="#度量分析-2" class="headerlink" title="度量分析"></a>度量分析</h3><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><img src="/2023/03/22/buaa-oo-2023-unit1/hw3_p.png" class="" title="hw3类图"><h4 id="代码量-2"><a href="#代码量-2" class="headerlink" title="代码量"></a>代码量</h4><img src="/2023/03/22/buaa-oo-2023-unit1/oo_unit1_hw3_statistic.png" class="" title="hw3代码量"><h4 id="类复杂度-2"><a href="#类复杂度-2" class="headerlink" title="类复杂度"></a>类复杂度</h4><img src="/2023/03/22/buaa-oo-2023-unit1/oo_unit1_hw3_classMetrics.png" class="" title="hw3类复杂度"><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ol><li>结合前两次代码中 Expr 类和 Term 类的复杂度较高的问题，我在第三次作业中将所有的化简方法(降幂、去括号、函数调用、求导、合并同类项)都从各自的结构类中分离出来，并统一写入 Simplify 类中。所以发现 Expr 类和 Term 类的复杂度降低，而 Simplify 类的复杂度很高。</li><li>Simplify 类中实现函数调用的方法实际上是调用了 Definition 类中将形参转化为实参操作的方法。而该方法复杂度较高，所以 Definition 类的复杂度较高。</li></ol><h3 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug"></a>Bug</h3><h4 id="自己代码中的-bug-1"><a href="#自己代码中的-bug-1" class="headerlink" title="自己代码中的 bug"></a>自己代码中的 bug</h4><ol><li>在解析求导算子时，方法 <code>parseDerivative</code> 的返回值类型为 <code>EXpr</code> ，而我返回的是将求导算子内的表达式求导后得到的表达式，这时忽略了该求导算子自带的正负号。</li><li>在对幂次大于 1 的三角函数进行求导时，没有正确使用链式法则。</li></ol><h4 id="同房其他人代码中的-bug-1"><a href="#同房其他人代码中的-bug-1" class="headerlink" title="同房其他人代码中的 bug"></a>同房其他人代码中的 bug</h4><p>在第三次作业的互测中，我依赖<a href="https://gitee.com/lu-yuheng/buaa_oo_unit1_xgen">鹿佬搭建的评测机</a><span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>找到了房友的较多处bug。</p><ol><li>对三角函数平方和求导时出现错误，问题应该出在优化的过程中；</li><li>解析自定义函数的定义式时出现标准异常；</li><li>表达式因子内只有一个常数因子且为负时，对该表达式因子的幂运算出现符号错误；</li><li>函数调用实参为求导因子，而求导算子后的因子又为函数调用时出现标准异常。</li></ol><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ol><li>在开始写代码前确定好大致的架构十分重要！这样不仅可以避免代码写到中途突然找不到方向，还可以减小重构的可能性；</li><li>自己做好测试，中测真的很弱！<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 第三次作业中在尝试提交并通过中测点后，并未对自己的代码进行进一步的测试，导致出现了 2 个很低级的错误；</li><li>从第一周的新奇与紧张到第四周完全熟悉了 OO 课程的模式，希望可以在接下来的三个单元中更加从容地应对挑战。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 面向对象设计与构造 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 递归下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_CO_2022_P7</title>
      <link href="/2023/03/22/buaa-co-2022-p7/"/>
      <url>/2023/03/22/buaa-co-2022-p7/</url>
      
        <content type="html"><![CDATA[<h1 id="P7-CPU-Document"><a href="#P7-CPU-Document" class="headerlink" title="P7_CPU_Document"></a>P7_CPU_Document</h1><hr><h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><table><thead><tr><th>任务</th><th>解释</th></tr></thead><tbody><tr><td>计时器</td><td>课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr><td>系统桥</td><td>为 CPU 提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr><td>协处理器 CP0</td><td>设置 CPU 的异常处理功能，反馈 CPU 的异常信息，需要按规格自行实现。</td></tr><tr><td>内部异常检测与流水</td><td>CPU 需要具有可以检测内部指令执行错误的能力。</td></tr><tr><td>外部中断响应</td><td>CPU 需要具有初步响应外部中断信号的能力。</td></tr><tr><td>异常处理指令</td><td>在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr><td>单周期 CPU 的封装</td><td>让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr><td>异常处理程序</td><td>利用 MARS 编写简单的异常处理程序用于测试。</td></tr></tbody></table><img src="/2023/03/22/buaa-co-2022-p7/%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="架构图"><h3 id="新增指令"><a href="#新增指令" class="headerlink" title="新增指令"></a>新增指令</h3><p>和 P6 相比， P7 主要新增了 mfc0, mtc0, syscall, eret 四条指令，mfc0 和 mtc0 的处理相对比较简单，且应该不涉及冒险冲突问题。</p><h4 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h4><p>这条指令在 P7 中直接视为一种异常来处理，开始时我因为忘记添加 `Exc_syscall 的判断而少了 interrupt count 。</p><h4 id="eret"><a href="#eret" class="headerlink" title="eret"></a>eret</h4><p>这条指令只会出现在异常处理程序的末尾，用来返回 EPC 。</p><p>首先要小心 EPC 的转发/阻塞问题。我在这里直接无脑阻塞了，并没有进行转发：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> Stall_eret <span class="token operator">=</span> eret_D <span class="token operator">&amp;</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>mtc0_E <span class="token operator">==</span> <span class="token number">1'b1</span> <span class="token operator">&amp;&amp;</span> rd_E <span class="token operator">==</span> <span class="token number">5'd14</span><span class="token punctuation">)</span> <span class="token operator">||</span>                     <span class="token punctuation">(</span>mtc0_M <span class="token operator">==</span> <span class="token number">1'b1</span> <span class="token operator">&amp;&amp;</span> rd_M <span class="token operator">==</span> <span class="token number">5'd14</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>eret 是一条跳转指令，但处于它的延迟槽中的指令是不会被执行的，我利用了 P5 中添加的清空延迟槽信号 flush 很简单地就解决了这一点。另外，由于延迟槽重的指令不会被执行，所以在 F 级判断取指异常时，不对 eret 延迟槽中的指令进行判断。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> ErrAdEL_F <span class="token operator">=</span> <span class="token punctuation">(</span>PC<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">2'b0</span> <span class="token operator">||</span> PC <span class="token operator">&lt;</span> <span class="token constant">`PC_MIN</span> <span class="token operator">||</span> PC <span class="token operator">&gt;</span> <span class="token constant">`PC_MAX</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>eret_D<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>eret 标志着异常处理程序的结束，所以直接将 eret_M 信号作为 EXLClr 输入给 CP0 以复位 EXL。</p><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>在 P7 中，我们要实现的中断和异常有以下几种：</p><img src="/2023/03/22/buaa-co-2022-p7/%E5%BC%82%E5%B8%B8%E7%A0%81.png" class="" title="异常码"><p>需要注意的是异常与中断的优先级问题</p><ol><li>对于同一条指令来说，先产生的异常优先于后产生的异常（比如 D 级的异常优先于 M 级的异常）</li><li>对于不同的指令来说，前面的指令产生的异常优先于后面的指令产生的异常（比如 M 级的异常优先于 D 级的异常）</li></ol><p>因此，采用下面这样的方式来表示此优先级问题：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> ExcCode_D <span class="token operator">=</span>  ExcCode_FD <span class="token operator">?</span> ExcCode_FD <span class="token punctuation">:</span>     ErrRI_D <span class="token operator">?</span> <span class="token constant">`Exc_RI</span> <span class="token punctuation">:</span>    syscall_D <span class="token operator">?</span> <span class="token constant">`Exc_Syscall</span> <span class="token punctuation">:</span>    <span class="token constant">`Exc_None</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ExcCode_E <span class="token operator">=</span>  ExcCode_DE <span class="token operator">?</span> ExcCode_DE <span class="token punctuation">:</span>    ErrOvAri_E <span class="token operator">?</span> <span class="token constant">`Exc_Ov</span> <span class="token punctuation">:</span>    <span class="token constant">`Exc_None</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ExcCode_M <span class="token operator">=</span>  ExcCode_EM <span class="token operator">?</span> ExcCode_EM <span class="token punctuation">:</span>    ErrAdEL_M <span class="token operator">?</span> <span class="token constant">`Exc_AdEL</span> <span class="token punctuation">:</span>    ErrAdES_M <span class="token operator">?</span> <span class="token constant">`Exc_AdES</span> <span class="token punctuation">:</span>    <span class="token constant">`Exc_None</span><span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="乘除槽"><a href="#乘除槽" class="headerlink" title="乘除槽"></a>乘除槽</h3><p>当产生异常时，已经开始或产生结果的乘除指令不会停止，而尚未开始执行的乘除指令不应进行。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// ......</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Req <span class="token operator">||</span> state <span class="token operator">!=</span> <span class="token number">4'd0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token comment">// ......</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CP0"><a href="#CP0" class="headerlink" title="CP0"></a>CP0</h3><p>CP0 模块的输入输出端口定义如下：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">CP0_WE</td><td align="center">写使能信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">CP0_addr</td><td align="center">寄存器地址（12/13/14)</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">CP0_in</td><td align="center">CP0写入数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">CP0_out</td><td align="center">CP0读出数据</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">VPC</td><td align="center">受害PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">isBD</td><td align="center">是否为延迟槽指令</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">ExcCode_in</td><td align="center">记录异常类型</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">HWInt</td><td align="center">输入中断信号</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">EXLClr</td><td align="center">EXL复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">EPC_out</td><td align="center">EPC输出</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">Req</td><td align="center">进入处理程序请求</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><p>CP0 模块的作用就是，当遇到中断或者异常时，判断是否对该中断或异常进行处理，并进行相应的记录操作。</p><p>在 P7 中，我们只实现了 CP0 的 3 个寄存器（12-SR, 13-Cause, 14-EPC）的某些位，相应部分的功能如下：</p><table><thead><tr><th>寄存器</th><th>功能域</th><th>位域</th><th>解释</th></tr></thead><tbody><tr><td>SR（State Register）</td><td>IM（Interrupt Mask）</td><td>15:10</td><td>分别对应六个外部中断，相应位置 1 表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过 <code>mtc0</code> 这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr><td>SR（State Register）</td><td>EXL（Exception Level）</td><td>1</td><td>任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr><td>SR（State Register）</td><td>IE（Interrupt Enable）</td><td>0</td><td>全局中断使能，该位置 1 表示允许中断，置 0 表示禁止中断。</td></tr><tr><td>Cause</td><td>BD（Branch Delay）</td><td>31</td><td>当该位置 1 的时候，EPC 指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr><td>Cause</td><td>IP（Interrupt Pending）</td><td>15:10</td><td>为 6 位待决的中断位，分别对应 6 个外部中断，相应位置 1 表示有中断，置 0 表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr><td>Cause</td><td>ExcCode</td><td>6:2</td><td>异常编码，记录当前发生的是什么异常。</td></tr><tr><td>EPC</td><td>-</td><td>-</td><td>记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><p>首先， Req 由两部分组成，中断和异常都会把 Req 置 1 ，即</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> Req_Int <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token constant">`IM</span> <span class="token operator">&amp;</span> HWInt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">`IE</span><span class="token punctuation">;</span> <span class="token comment">// 中断未被屏蔽 且 检测到中断 且 允许中断</span><span class="token keyword">wire</span> Req_Exc <span class="token operator">=</span> <span class="token punctuation">(</span>ExcCode_in <span class="token operator">!=</span> <span class="token constant">`Exc_None</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 检测到异常</span><span class="token keyword">assign</span> Req <span class="token operator">=</span> <span class="token punctuation">(</span>Req_Int <span class="token operator">|</span> Req_Exc<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token constant">`EXL</span><span class="token punctuation">;</span> <span class="token comment">// 检测到允许的中断或异常 且 不在处理程序中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在每个时钟周期，如果 Req 有效，应当将相应的信息记录在 CP0 相应的寄存器中。需要注意的是， EPC 是异常处理程序结束后（即 eret 指令）要跳转到的 PC 值。如果异常的指令位于前一条指令的延迟槽中，这里应当返回到前一条指令的 PC ，否则，应该跳转到受害 PC，即</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token comment">// ......</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Req<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token constant">`EXL</span> <span class="token operator">&lt;=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token constant">`ExcCode</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>Req_Int <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">`Exc_Int</span> <span class="token punctuation">:</span> ExcCode_in<span class="token punctuation">;</span>        <span class="token constant">`BD</span> <span class="token operator">=</span> isBD<span class="token punctuation">;</span>        EPC <span class="token operator">&lt;=</span> EPC_out<span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token comment">// ......</span><span class="token keyword">end</span><span class="token keyword">assign</span> EPC_out <span class="token operator">=</span> <span class="token punctuation">(</span>Req<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>isBD <span class="token operator">?</span> VPC <span class="token operator">-</span> <span class="token number">32'd4</span> <span class="token punctuation">:</span> VPC<span class="token punctuation">)</span> <span class="token punctuation">:</span> EPC<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，不要忘了每个时钟周期要把 HWInt 的值更新到 IP 中</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// ......</span><span class="token constant">`IP</span> <span class="token operator">&lt;=</span> HWInt<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="封装为单周期-CPU"><a href="#封装为单周期-CPU" class="headerlink" title="封装为单周期 CPU"></a>封装为单周期 CPU</h3><p>在 P5, P6 中，我们设计的 CPU 是流水线 CPU ，而在 P7 要设计的 MIPS 微系统中， CPU 只是其中的一个组成部分。从 CPU 内部来看，它是流水线 CPU ，而从外部来看，我们不关心它的内部是如何实现的，而是要让看上去是一个单周期的 CPU 。据此，我们引入了“宏观 PC ”的概念，来表示该指令之前的所有指令序列对 CPU 的更新已完成，该指令及其之后的指令序列对 CPU 的更新未完成。在我的设计中，宏观 PC 即为 M 级 PC 。</p><p>封装后的 CPU 输入和输出端口如下：</p><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">I</td><td align="center">时钟信号</td></tr><tr><td align="center">reset</td><td align="center">I</td><td align="center">同步复位信号</td></tr><tr><td align="center">HWInt[5:0]</td><td align="center">I</td><td align="center"></td></tr><tr><td align="center">i_inst_addr [31:0]</td><td align="center">O</td><td align="center">IM 读地址</td></tr><tr><td align="center">i_inst_rdata [31:0]</td><td align="center">I</td><td align="center">IM 读数据</td></tr><tr><td align="center">m_data_addr [31:0]</td><td align="center">O</td><td align="center">M 级读写地址</td></tr><tr><td align="center">m_data_rdata [31:0]</td><td align="center">I</td><td align="center">M 级读数据</td></tr><tr><td align="center">m_data_wdata [31:0]</td><td align="center">O</td><td align="center">M 级待写入数据</td></tr><tr><td align="center">m_data_byteen [3:0]</td><td align="center">O</td><td align="center">M 级字节使能信号</td></tr><tr><td align="center">m_inst_addr [31:0]</td><td align="center">O</td><td align="center">M 级 PC</td></tr><tr><td align="center">PC_M</td><td align="center">O</td><td align="center">GRF 写使能信号</td></tr><tr><td align="center">w_grf_we</td><td align="center">O</td><td align="center">GRF 写使能信号</td></tr><tr><td align="center">w_grf_addr [4:0]</td><td align="center">O</td><td align="center">GRF 中待写入寄存器编号</td></tr><tr><td align="center">w_grf_wdata [31:0]</td><td align="center">O</td><td align="center">GRF 中待写入数据</td></tr><tr><td align="center">w_inst_addr [31:0]</td><td align="center">O</td><td align="center">W 级 PC</td></tr><tr><td align="center">Req</td><td align="center">O</td><td align="center">异常信号</td></tr></tbody></table><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>Bridge 模块的输入和输出端口如下：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">Req</td><td align="center">异常信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">DM_out</td><td align="center">DM读数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">TC_out1</td><td align="center">TC1读数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">TC_out2</td><td align="center">TC2读数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">Addr</td><td align="center">读写地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">m_data_byteen</td><td align="center">写使能</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">D_out</td><td align="center">Bridge输出</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">TC_WE1</td><td align="center">TC1写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">TC_WE2</td><td align="center">TC2写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">m_int_addr</td><td align="center">中断发生器待写入地址</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">m_int_byteen</td><td align="center">中断发生器字节使能信号</td><td align="center">4</td><td align="center">O</td></tr></tbody></table><p>CPU 与 外设（这里是 DM, TC1, TC2, InterruptGenerator）的沟通都是通过 Bridge 来实现的。</p><p>这里列出 P7 中规定的地址空间分配：</p><table><thead><tr><th>条目</th><th>地址或地址范围</th><th>备注</th></tr></thead><tbody><tr><td>数据存储器</td><td>0x0000_0000∼0x0000_2FFF</td><td></td></tr><tr><td>指令存储器</td><td>0x0000_3000∼0x0000_6FFF</td><td></td></tr><tr><td>PC 初始值</td><td>0x0000_3000</td><td></td></tr><tr><td>异常处理程序入口地址</td><td>0x0000_4180</td><td></td></tr><tr><td>计时器 0 寄存器地址</td><td>0x0000_7F00∼0x0000_7F0B</td><td>计时器 0 的 3 个寄存器</td></tr><tr><td>计时器 1 寄存器地址</td><td>0x0000_7F10∼0x0000_7F1B</td><td>计时器 1 的 3 个寄存器</td></tr><tr><td>中断发生器响应地址</td><td>0x0000_7F20∼0x0000_7F23</td><td></td></tr></tbody></table><p>对于读数据来说，我们把各个外设的读数据都输入到 Bridge 中，根据 CPU 传来的地址不同，反馈给 CPU 不同的读数据。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> D_out <span class="token operator">=</span>  <span class="token punctuation">(</span>Addr <span class="token operator">&gt;=</span> <span class="token constant">`DM_begin</span> <span class="token operator">&amp;&amp;</span> Addr <span class="token operator">&lt;=</span> <span class="token constant">`DM_end</span><span class="token punctuation">)</span> <span class="token operator">?</span> DM_out <span class="token punctuation">:</span>                <span class="token punctuation">(</span>Addr <span class="token operator">&gt;=</span> <span class="token constant">`TC1_begin</span> <span class="token operator">&amp;&amp;</span> Addr <span class="token operator">&lt;=</span> <span class="token constant">`TC1_end</span><span class="token punctuation">)</span> <span class="token operator">?</span> TC_out1 <span class="token punctuation">:</span>                <span class="token punctuation">(</span>Addr <span class="token operator">&gt;=</span> <span class="token constant">`TC2_begin</span> <span class="token operator">&amp;&amp;</span> Addr <span class="token operator">&lt;=</span> <span class="token constant">`TC2_end</span><span class="token punctuation">)</span> <span class="token operator">?</span> TC_out2 <span class="token punctuation">:</span>                <span class="token number">32'b0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于写数据来说，实际上 CPU 将要写的数据传入 Bridge ，我在实现的时候直接将 m_data_wdata 传入各个外设了。然后 Bridge 通过 CPU 传入读写地址以及写使能信号来生成各个外设的写使能信号，从而实现控制写外设的功能。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> TC_WE1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span>m_data_byteen<span class="token punctuation">)</span> <span class="token operator">&amp;</span>    <span class="token operator">!</span>Req <span class="token operator">&amp;</span>    <span class="token punctuation">(</span>Addr <span class="token operator">&gt;=</span> <span class="token constant">`TC1_begin</span> <span class="token operator">&amp;&amp;</span> Addr <span class="token operator">&lt;=</span> <span class="token constant">`TC1_end</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TC1 写使能</span><span class="token keyword">assign</span> TC_WE2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">|</span>m_data_byteen<span class="token punctuation">)</span> <span class="token operator">&amp;</span>    <span class="token operator">!</span>Req <span class="token operator">&amp;</span>    <span class="token punctuation">(</span>Addr <span class="token operator">&gt;=</span> <span class="token constant">`TC2_begin</span> <span class="token operator">&amp;&amp;</span> Addr <span class="token operator">&lt;=</span> <span class="token constant">`TC2_end</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TC2 写使能</span><span class="token keyword">assign</span> m_data_byteen <span class="token operator">=</span> Req <span class="token operator">?</span> <span class="token number">4'b0000</span> <span class="token punctuation">:</span> DM_WE<span class="token punctuation">;</span> <span class="token comment">// DM 写使能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外， P7 要求在 mips 的输出端口中输出 m_int_addr （中断发生器待写入地址）和 m_int_byteen （中断发生器字节使能信号）：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> m_int_addr <span class="token operator">=</span> Addr<span class="token punctuation">;</span><span class="token keyword">assign</span> m_int_byteen <span class="token operator">=</span> <span class="token punctuation">(</span>Addr <span class="token operator">&gt;=</span> <span class="token constant">`Int_begin</span> <span class="token operator">&amp;&amp;</span> Addr <span class="token operator">&lt;=</span> <span class="token constant">`Int_end</span><span class="token punctuation">)</span> <span class="token operator">?</span> m_data_byteen <span class="token punctuation">:</span>     <span class="token number">4'b0000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>答：鼠标和键盘产生中断信号 interrupt ，中断信号从中断发生器经由 Bridge 传给 CPU 。</p><p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU  支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>答：P7 规定了异常处理程序的入口地址为 0x0000_4180 ，正常情况下应该只能通过异常和中断来访问异常处理程序，如果自定义入口地址的话， CPU 无法对其加以限制，可能出现无异常或中断仍进入处理程序的情况。</p><p>3、为何与外设通信需要 Bridge？</p><p>答：如果把 CPU 和每一个外设都直接相连，不仅会复杂化 CPU 的端口，而且在添加或删除外设时又要重新修改 CPU 的端口。通过 Bridge ，我们可以将所有外设同等看待，而且 CPU 只需给出要访存的外设地址和相应数据， Bridge 就可以帮助 CPU 进行相应的访存操作。</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>答：两种中断模式的不同点就在于计数结束后，模式 0 自动将使能信号置为 0 ，而模式 1 不改变使能信号，而是将中断信号置为 0 。</p><img src="/2023/03/22/buaa-co-2022-p7/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE.jpg" class="" title="定时器状态转移"><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>答：空泡流水的宏观 PC 为 0 ，其所有信号都为 0 。如果此时产生中断信号，输入 CP0 的 VPC  和 isBD 值为 0 ， EPC 中就会存入错误的值。所以为了保证 CP0 正常工作不出现错误，在清空流水线产生的空泡指令应当保留原指令的 PC 和 isBD 信号。</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><p>答：当两个寄存器相同时，如果延迟槽中的指令出现了异常，则会重新执行 jalr 指令，但之前执行的 jalr 指令并不会撤销，也就是要载入 PC 的寄存器已经被改写了，这样就会出现错误。</p><p>为啥无异常的时候 Mars 也无法正常跳转？</p><p>看了英文指令集，发现是因为这条指令是先写入寄存器，再执行延迟槽，然后再跳转到相应的 PC 。</p><h2 id="导出中断处理程序"><a href="#导出中断处理程序" class="headerlink" title="导出中断处理程序"></a>导出中断处理程序</h2><p>导出中断处理程序，命令如下：</p><pre class="line-numbers language-none"><code class="language-none">java -jar E:\Mars4_5.jar a db mc CompactDataAtZero dump 0x00004180-0x00004ffc HexText E:\code_handler.txt E:\source.txtjava -jar ‪D:\study\CO\P7\Mars_p7\Mars.jar a db mc CompactDataAtZero dump 0x00004180-0x00004ffc HexText ‪D:\study\CO\P7\P7_MIPS\handler.txt D:\study\CO\P7\Mars_p7\mips1.asm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解析：</p><ul><li><p><code>E:\Mars4_5.jar</code> 是 MARS 的文件路径</p></li><li><p><code>a db mc CompactDataAtZero dump</code> 参数</p></li><li><p><code>0x00004180-0x00004ffc</code> 是需要导出的地址范围</p></li><li><p><code>HexText</code> 表示导出的是 16 进制码</p></li><li><p><code>E:\code_handler.txt</code> 是 16 进制码输出文件路径</p></li><li><p><code>E:\source.txt</code> 是源文件路径</p></li></ul><h2 id="课上（12-6）"><a href="#课上（12-6）" class="headerlink" title="课上（12.6）"></a>课上（12.6）</h2><p> CP0 的输入数据应当是转发后的数据，而不是流水来的 $GPR[rt]$ 。</p><h2 id="课下-BUG"><a href="#课下-BUG" class="headerlink" title="课下 BUG"></a>课下 BUG</h2><h3 id="中测"><a href="#中测" class="headerlink" title="中测"></a>中测</h3><ol><li>乘除模块忘记添加 Req 输入端口了；</li><li>忘记添加 syscall 的异常判断了；</li><li>好像是更改了Stall就莫名其妙对了（？）</li></ol><p>CP0_RD 的转发</p><p>PC值向4180的跳转</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_CO_2022_P6</title>
      <link href="/2023/03/22/buaa-co-2022-p6/"/>
      <url>/2023/03/22/buaa-co-2022-p6/</url>
      
        <content type="html"><![CDATA[<h1 id="P6-CPU-Document"><a href="#P6-CPU-Document" class="headerlink" title="P6_CPU_Document"></a>P6_CPU_Document</h1><hr><h2 id="流水线架构"><a href="#流水线架构" class="headerlink" title="流水线架构"></a>流水线架构</h2><table><thead><tr><th>阶段</th><th>简称</th><th>功能概述</th></tr></thead><tbody><tr><td>取指阶段（Fetch）</td><td>F</td><td>从指令存储器中读取指令</td></tr><tr><td>译码阶段（Decode）</td><td>D</td><td>从寄存器文件中读取源操作数并对指令译码以便得到控制信号</td></tr><tr><td>执行阶段（Execute）</td><td>E</td><td>使用 ALU 执行计算</td></tr><tr><td>存储阶段（Memory）</td><td>M</td><td>读或写数据存储器</td></tr><tr><td>写回阶段（Writeback）</td><td>W</td><td>将结果写回到寄存器文件</td></tr></tbody></table><ul><li>流水线寄存器以其供给数据的流水级的简称命名</li></ul><h3 id="顶层模块"><a href="#顶层模块" class="headerlink" title="顶层模块"></a>顶层模块</h3><h4 id="mips-v"><a href="#mips-v" class="headerlink" title="mips.v"></a>mips.v</h4><p>接口定义如下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">mips</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> reset<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> i_inst_rdata<span class="token punctuation">,</span>    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_rdata<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> i_inst_addr<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_addr<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_wdata<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_byteen<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_inst_addr<span class="token punctuation">,</span>    <span class="token keyword">output</span> w_grf_we<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_grf_addr<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_grf_wdata<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_inst_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">I</td><td align="center">时钟信号</td></tr><tr><td align="center">reset</td><td align="center">I</td><td align="center">同步复位信号</td></tr><tr><td align="center">i_inst_rdata [31:0]</td><td align="center">I</td><td align="center">i_inst_addr 对应的 32 位指令</td></tr><tr><td align="center">m_data_rdata [31:0]</td><td align="center">I</td><td align="center">m_data_addr 对应的 32 位数据</td></tr><tr><td align="center">i_inst_addr [31:0]</td><td align="center">O</td><td align="center">需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr><td align="center">m_data_addr [31:0]</td><td align="center">O</td><td align="center">数据存储器待写入地址</td></tr><tr><td align="center">m_data_wdata [31:0]</td><td align="center">O</td><td align="center">数据存储器待写入数据</td></tr><tr><td align="center">m_data_byteen [3:0]</td><td align="center">O</td><td align="center">字节使能信号</td></tr><tr><td align="center">m_inst_addr [31:0]</td><td align="center">O</td><td align="center">M 级 PC</td></tr><tr><td align="center">w_grf_we</td><td align="center">O</td><td align="center">GRF 写使能信号</td></tr><tr><td align="center">w_grf_addr [4:0]</td><td align="center">O</td><td align="center">GRF 中待写入寄存器编号</td></tr><tr><td align="center">w_grf_wdata [31:0]</td><td align="center">O</td><td align="center">GRF 中待写入数据</td></tr><tr><td align="center">w_inst_addr [31:0]</td><td align="center">O</td><td align="center">W 级 PC</td></tr></tbody></table><h3 id="存储器外置"><a href="#存储器外置" class="headerlink" title="存储器外置"></a>存储器外置</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps<span class="token keyword">module</span> mips_txt<span class="token punctuation">;</span>    <span class="token keyword">reg</span> clk<span class="token punctuation">;</span>    <span class="token keyword">reg</span> reset<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> i_inst_addr<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> i_inst_rdata<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_addr<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_rdata<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_wdata<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_data_byteen<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> m_inst_addr<span class="token punctuation">;</span>    <span class="token keyword">wire</span> w_grf_we<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_grf_addr<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_grf_wdata<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> w_inst_addr<span class="token punctuation">;</span>    mips <span class="token function">uut</span><span class="token punctuation">(</span>        <span class="token punctuation">.</span><span class="token function">clk</span><span class="token punctuation">(</span>clk<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">i_inst_addr</span><span class="token punctuation">(</span>i_inst_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">i_inst_rdata</span><span class="token punctuation">(</span>i_inst_rdata<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">m_data_addr</span><span class="token punctuation">(</span>m_data_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">m_data_rdata</span><span class="token punctuation">(</span>m_data_rdata<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">m_data_wdata</span><span class="token punctuation">(</span>m_data_wdata<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">m_data_byteen</span><span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">m_inst_addr</span><span class="token punctuation">(</span>m_inst_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">w_grf_we</span><span class="token punctuation">(</span>w_grf_we<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">w_grf_addr</span><span class="token punctuation">(</span>w_grf_addr<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">w_grf_wdata</span><span class="token punctuation">(</span>w_grf_wdata<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">.</span><span class="token function">w_inst_addr</span><span class="token punctuation">(</span>w_inst_addr<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">integer</span> i<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> fixed_addr<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> fixed_wdata<span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4095</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> inst<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4095</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> m_data_rdata <span class="token operator">=</span> data<span class="token punctuation">[</span>m_data_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">assign</span> i_inst_rdata <span class="token operator">=</span> inst<span class="token punctuation">[</span><span class="token punctuation">(</span>i_inst_addr <span class="token operator">-</span> <span class="token number">32'h3000</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">initial</span> <span class="token keyword">begin</span>        <span class="token kernel-function property">$readmemh</span><span class="token punctuation">(</span><span class="token string">"code.txt"</span><span class="token punctuation">,</span> inst<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">initial</span> <span class="token keyword">begin</span>        clk <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        reset <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token number">#20</span> reset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>        fixed_wdata <span class="token operator">=</span> data<span class="token punctuation">[</span>m_data_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        fixed_addr <span class="token operator">=</span> m_data_addr <span class="token operator">&amp;</span> <span class="token number">32'hfffffffc</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_data_byteen<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> fixed_wdata<span class="token punctuation">[</span><span class="token number">7</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> m_data_wdata<span class="token punctuation">[</span><span class="token number">7</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">|</span>m_data_byteen<span class="token punctuation">)</span> <span class="token keyword">begin</span>            data<span class="token punctuation">[</span>fixed_addr <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> fixed_wdata<span class="token punctuation">;</span>            <span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"%d@%h: *%h &lt;= %h"</span><span class="token punctuation">,</span> <span class="token kernel-function property">$time</span><span class="token punctuation">,</span> m_inst_addr<span class="token punctuation">,</span> fixed_addr<span class="token punctuation">,</span> fixed_wdata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//$display("@%h: *%h &lt;= %h", m_inst_addr, fixed_addr, fixed_wdata);</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>w_grf_we <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>w_grf_addr <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>                <span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">"%d@%h: $%d &lt;= %h"</span><span class="token punctuation">,</span> <span class="token kernel-function property">$time</span><span class="token punctuation">,</span> w_inst_addr<span class="token punctuation">,</span> w_grf_addr<span class="token punctuation">,</span> w_grf_wdata<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//$display("@%h: $%d &lt;= %h", w_inst_addr, w_grf_addr, w_grf_wdata);</span>            <span class="token keyword">end</span>        <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token important">always</span> <span class="token number">#2</span> clk <span class="token operator">&lt;=</span> <span class="token operator">~</span>clk<span class="token punctuation">;</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取指阶段（Fetch）"><a href="#取指阶段（Fetch）" class="headerlink" title="取指阶段（Fetch）"></a>取指阶段（Fetch）</h3><h4 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h4><p>这里的 $PC$ 采用下面这种方式直接<strong>在顶层模块 $mips$ 中</strong>实现：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> PC<span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>    PC <span class="token operator">=</span> <span class="token number">32'h00003000</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        PC <span class="token operator">&lt;=</span> <span class="token number">32'h00003000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        PC <span class="token operator">&lt;=</span> NPC_NPC<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="npc-v"><a href="#npc-v" class="headerlink" title="npc.v"></a>npc.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">Stall</td><td align="center">暂停信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">HILO_BUSY</td><td align="center">乘除指令阻塞信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">isHILO</td><td align="center">乘除指令判断信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">当前指令地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">imm26</td><td align="center">26位立即数</td><td align="center">26</td><td align="center">I</td></tr><tr><td align="center">EXT</td><td align="center">位扩展器结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">RD1</td><td align="center">寄存器读数据1</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">nPC_sel</td><td align="center">跳转控制信号</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">isSame</td><td align="center">相等比较信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">NPC</td><td align="center">下一条指令地址</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">flush</td><td align="center">清空延迟槽信号</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><ul><li>若暂停信号 $Stall$ 有效或信号 $HILO_BUSY$ 和 $isHILO$ <strong>同时</strong>有效，则 $NPC$ 保持不变</li><li>若对应指令满足清空延迟槽条件，则输出清空延迟槽信号 $flush$ 为 $1$</li></ul><h4 id="d-reg-v"><a href="#d-reg-v" class="headerlink" title="d_reg.v"></a>d_reg.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">Stall</td><td align="center">暂停信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">HILO_BUSY</td><td align="center">乘除指令阻塞信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">isHILO</td><td align="center">乘除指令判断信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">flush</td><td align="center">清空延迟槽</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">instr_in</td><td align="center">F级指令</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">F级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">instr_out</td><td align="center">D级指令</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">PC_out</td><td align="center">D级PC</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ul><li>若暂停信号 $Stall$ 有效或信号 $HILO_BUSY$ 和 $isHILO$ <strong>同时</strong>有效，则 $instr_out$ 与 $PC_out$ 保持不变</li><li>若清空延迟槽信号 $flush$ 有效<strong>且暂停信号 $Stall$ 无效</strong>，则清空 $D$ 级寄存器</li></ul><h3 id="译码阶段（Decord）"><a href="#译码阶段（Decord）" class="headerlink" title="译码阶段（Decord）"></a>译码阶段（Decord）</h3><h4 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h4><p>当一个指令到达 $D$ 级后，我们需要将它的 $T_{use}$ 值与后面每一级的 $T_{new}$ 进行比较，并进行 $A$ 值的校验。</p><ul><li><p>当 $T_{use} ≥ T_{new}$ 时，我们可以通过<strong>转发</strong>来解决冒险 </p></li><li><p>当 $T_{use} &lt; T_{new}$ 时，我们就需要<strong>阻塞</strong>流水线</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> Stall_RS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rs <span class="token operator">&lt;</span> T_new_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> A3_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_E<span class="token punctuation">)</span> <span class="token operator">|</span>                   <span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rs <span class="token operator">&lt;</span> T_new_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> A3_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>    <span class="token punctuation">(</span>rs <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> Stall_RT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rt <span class="token operator">&lt;</span> T_new_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> A3_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_E<span class="token punctuation">)</span> <span class="token operator">|</span>                   <span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rt <span class="token operator">&lt;</span> T_new_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> A3_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>    <span class="token punctuation">(</span>rt <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> Stall <span class="token operator">=</span> Stall_RS <span class="token operator">|</span> Stall_RT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ctrl-v"><a href="#ctrl-v" class="headerlink" title="ctrl.v"></a>ctrl.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">op</td><td align="center">指令操作码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">funct</td><td align="center">指令功能码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">RegDst</td><td align="center">GRF写地址选择信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ExtOp</td><td align="center">位扩展控制码</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ALUSrc</td><td align="center">ALU操作数B选择信号</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">ALUOP</td><td align="center">ALU控制码</td><td align="center">4</td><td align="center">O</td></tr><tr><td align="center">isHILO</td><td align="center">乘除指令信号</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">HILOtype</td><td align="center">乘除指令信号类型</td><td align="center">4</td><td align="center">O</td></tr><tr><td align="center">RegWrite</td><td align="center">寄存器写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemWrite</td><td align="center">数据存储器写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg</td><td align="center">寄存器写数据选择信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">storeOP</td><td align="center">数据存储器写数据控制信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">DextOP</td><td align="center">数据存储器数据扩展信号</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">nPC_sel</td><td align="center">跳转控制信号</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">T_use_rs</td><td align="center">GPR[rs]的需求时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">T_use_rt</td><td align="center">GPR[rt]的需求时间</td><td align="center">2</td><td align="center">O</td></tr></tbody></table><p>这里采用了<strong>控制信号驱动型</strong>的<strong>集中式译码</strong></p><ul><li>控制信号</li></ul><table><thead><tr><th align="center"></th><th align="center">add(addu)</th><th align="center">sub(subu)</th><th align="center">and(or)</th><th align="center">slt(sltu)</th><th align="center">addi(addiu)</th><th align="center">andi(ori)</th><th align="center">lui</th><th align="center">mult/div</th><th align="center">mt</th><th align="center">mf</th><th align="center">load</th><th align="center">store</th><th align="center">beq</th><th align="center">bne</th><th align="center">jal</th><th align="center">jr</th><th align="center">j</th></tr></thead><tbody><tr><td align="center"><strong>RegDst</strong></td><td align="center">rd</td><td align="center">rd</td><td align="center">rd</td><td align="center">rd</td><td align="center">rt</td><td align="center">rt</td><td align="center">rt</td><td align="center">X</td><td align="center">X</td><td align="center">rd</td><td align="center">rt</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">ra</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>ExtOp</strong></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">SIGN</td><td align="center">ZERO</td><td align="center">HIGN</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">SIGN</td><td align="center">SIGN</td><td align="center">SIGN</td><td align="center">SIGN</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>ALUSrc</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>ALUOP</strong></td><td align="center">ADD</td><td align="center">SUB</td><td align="center">AND(OR)</td><td align="center">SLT(SLTU)</td><td align="center">ADD</td><td align="center">AND(OR)</td><td align="center">ADD</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">ADD</td><td align="center">ADD</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>RegWrite</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><strong>MemtoReg</strong></td><td align="center">ALU</td><td align="center">ALU</td><td align="center">ALU</td><td align="center">ALU</td><td align="center">ALU</td><td align="center">ALU</td><td align="center">ALU</td><td align="center">X</td><td align="center">X</td><td align="center">HILO</td><td align="center">DM</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">PC</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>nPC_sel</strong></td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">BEQ</td><td align="center">BNE</td><td align="center">J</td><td align="center">JR</td><td align="center">J</td></tr><tr><td align="center"><strong>T_use_rs</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">3</td><td align="center">0</td><td align="center">3</td></tr><tr><td align="center"><strong>T_use_rt</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">0</td><td align="center">3</td><td align="center">3</td><td align="center">3</td></tr></tbody></table><ol><li>信号 $isHILO$ 与 $HILOtype$ 只对指令 $mult, multu, div, divu, mthi, mtlo, mfhi, mflo$ 生效，未列于表中</li><li>信号 $storeOP$ 只对指令 $sw(2’d1), sh(2’d2), sb(2’d3)$ 生效，未列于表中</li><li>信号 $DextOP$ 只对指令 $lw(dext_lw), lh(dext_lh), lhu(dext_lhu), lb(dext_lb), lbu(dext_lbu)$ 生效，未列于表中</li><li>指令的需求时间 $T_{use}$ 是指这条指令位于 $D$ 级的时候，<strong>再经过多少个时钟周期就必须要使用相应的数据</strong></li><li>实际上， $T_{use}$ 的最大值为 $2’d2$ ，当指令用不到 $GPR[rs]$ 或 $GPR[rt]$ 时，我们将对应的置 $T_{use}$ 为 $2’d3$ ，这并不会影响我们对转发和暂停的判断</li></ol><h4 id="grf-v"><a href="#grf-v" class="headerlink" title="grf.v"></a>grf.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">RegWrite</td><td align="center">寄存器写使能</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">当前指令的地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A1</td><td align="center">读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2</td><td align="center">读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A3</td><td align="center">读地址3</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">WD</td><td align="center">写数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">RD1</td><td align="center">输出A1指定的寄存器数据</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">RD2</td><td align="center">输出A2指定的寄存器数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="ext-v"><a href="#ext-v" class="headerlink" title="ext.v"></a>ext.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">imm16</td><td align="center">16位立即数</td><td align="center">16</td><td align="center">I</td></tr><tr><td align="center">ExtOP</td><td align="center">位扩展控制码</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">EXT_Result</td><td align="center">位扩展结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="cmp-v"><a href="#cmp-v" class="headerlink" title="cmp.v"></a>cmp.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">GRF_RD1</td><td align="center">GRF读数据1</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">GRF_RD2</td><td align="center">GRF读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">isSame</td><td align="center">相等比较信号</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><ul><li>这里添加一个 $CMP$ 模块是为了将**$B$ 类跳转指令的<strong>判定</strong>提前至 $D$ 级**来进行，不再使用 $E$ 级的 $ALU$ 来进行判定</li></ul><h4 id="e-reg-v"><a href="#e-reg-v" class="headerlink" title="e_reg.v"></a>e_reg.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">Stall</td><td align="center">暂停信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">HILO_BUSY</td><td align="center">乘除指令阻塞信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">isHILO</td><td align="center">乘除指令判断信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">D级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">op</td><td align="center">D级指令操作码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">funct</td><td align="center">D级指令功能码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">shamt_in</td><td align="center">D级shamt</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALUSrc_in</td><td align="center">D级ALUSrc</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">ALUOP_in</td><td align="center">D级ALUOP</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">RegWrite_in</td><td align="center">D级RegWrite</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemtoReg_in</td><td align="center">D级MemtoReg</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">storeOP_in</td><td align="center">D级storeOP</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">DextOP_in</td><td align="center">D级DextOP</td><td align="center">3</td><td align="center">I</td></tr><tr><td align="center">A1_in</td><td align="center">D级寄存器读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2_in</td><td align="center">D级寄存器读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">GRF_RD1_in</td><td align="center">D级寄存器读数据1</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">GRF_RD2_in</td><td align="center">D级寄存器读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A3_in</td><td align="center">D级寄存器写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">EXT_Result_in</td><td align="center">D级位扩展结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_out</td><td align="center">E级PC</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">shamt_out</td><td align="center">E级shamt</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">T_new</td><td align="center">E级指令供给时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ALUSrc_out</td><td align="center">E级ALUSrc</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">ALUOP_out</td><td align="center">E级ALUOP</td><td align="center">4</td><td align="center">O</td></tr><tr><td align="center">RegWrite_out</td><td align="center">E级RegWrite</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg_out</td><td align="center">E级MemtoReg</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">storeOP</td><td align="center">E级storeOP</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">DextOP</td><td align="center">E级DextOP</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">A1_out</td><td align="center">E级寄存器读地址1</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">A2_out</td><td align="center">E级寄存器读地址2</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">GRF_RD1_out</td><td align="center">E级寄存器读数据1</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">GRF_RD2_out</td><td align="center">E级寄存器读数据2</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">A3_out</td><td align="center">E级寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">EXT_Result_out</td><td align="center">E级位扩展结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ul><li>指令的供给时间 $T_{new}$ 是指位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且<strong>存储到流水级寄存器里</strong></li><li>若暂停信号 $Stall$ 有效或信号 HILO_BUSY 和 isHILO <strong>同时</strong>有效，则清空 $E_REG$ (效果同 $reset$ )</li></ul><h3 id="执行阶段（Excute）"><a href="#执行阶段（Excute）" class="headerlink" title="执行阶段（Excute）"></a>执行阶段（Excute）</h3><h4 id="alu-v"><a href="#alu-v" class="headerlink" title="alu.v"></a>alu.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">操作数A</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">B</td><td align="center">操作数B</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">shamt</td><td align="center">移位数</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALUOp</td><td align="center">ALU控制码</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">C</td><td align="center">运算结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="md-v"><a href="#md-v" class="headerlink" title="md.v"></a>md.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">HILOtype</td><td align="center">乘除指令类型</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">A</td><td align="center">操作数A</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">B</td><td align="center">操作数B</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">HILO_BUSY</td><td align="center">乘除模块BUSY信号</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">HILO</td><td align="center">乘除模块输出</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ol><li>乘除指令（$mult,multu,div,divu$）会产生有效一个周期的 $start$ 信号</li><li>乘法信号会在 $start$ 后产生有效5个周期的 $busy$ 信号，除法信号会在 $start$ 后产生有效10个周期的 $busy$ 信号</li><li>在 $busy$ 的最后一个周期才会将计算结果写入 $HI/LO$ 寄存器</li></ol><h4 id="m-meg-v"><a href="#m-meg-v" class="headerlink" title="m_meg.v"></a>m_meg.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">E级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">T_new_in</td><td align="center">E级指令供给时间</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">RegWrite_in</td><td align="center">E级RegWrite</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemtoReg_in</td><td align="center">E级MemtoReg</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">storeOP_in</td><td align="center">E级storeOP</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">DextOP_in</td><td align="center">E级DextOP</td><td align="center">3</td><td align="center">I</td></tr><tr><td align="center">A1_in</td><td align="center">E级寄存器读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2_in</td><td align="center">E级寄存器读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A3_in</td><td align="center">E级寄存器写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALU_C_in</td><td align="center">E级ALU计算结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">GRF_RD2_in</td><td align="center">E级寄存器读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_out</td><td align="center">M级PC</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">T_new_out</td><td align="center">M级指令供给时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">RegWrite_out</td><td align="center">M级RegWrite</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg_out</td><td align="center">M级MemtoReg</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">storeOP_out</td><td align="center">M级storeOP</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">DextOP_out</td><td align="center">M级DextOP</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">A1_out</td><td align="center">M级寄存器读地址1</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">A2_out</td><td align="center">M级寄存器读地址2</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">A3_out</td><td align="center">M级寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">ALU_C_out</td><td align="center">M级ALU计算结果</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">GRF_RD2_out</td><td align="center">M级寄存器读数据2</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h3 id="存储阶段（Memory"><a href="#存储阶段（Memory" class="headerlink" title="存储阶段（Memory)"></a>存储阶段（Memory)</h3><h4 id="dext-v"><a href="#dext-v" class="headerlink" title="dext.v"></a>dext.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">数据存储器读地址的低2位</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">D_in</td><td align="center">数据存储器读地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">dextOP</td><td align="center">数据扩展信号</td><td align="center">3</td><td align="center">I</td></tr><tr><td align="center">D_out</td><td align="center">数据扩展结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="w-reg-v"><a href="#w-reg-v" class="headerlink" title="w_reg.v"></a>w_reg.v</h4><ul><li>端口定义</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">M级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">T_new_in</td><td align="center">M级指令供给时间</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">RegWrite_in</td><td align="center">M级RegWrite</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemtoReg_in</td><td align="center">M级MemtoReg</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">A3_in</td><td align="center">M级寄存器写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALU_C_in</td><td align="center">M级ALU计算结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">DM_RD_in</td><td align="center">M级DM读数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_out</td><td align="center">W级PC</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">T_new_out</td><td align="center">W级指令供给时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">RegWrite_out</td><td align="center">W级RegWrite</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg_out</td><td align="center">W级MemtoReg</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">A3_out</td><td align="center">W级寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">ALU_C_out</td><td align="center">W级ALU计算结果</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">DM_RD_out</td><td align="center">W级DM读数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</p><p>答：乘除法需要若干个周期来完成，且需要将计算结果存入 HI、 LO 寄存器中。 HI 、 LO 的值只有在遇到 $mfhi,mflo$ 指令时才取出，且遇到 $mthi,mtlo$ 指令时要将数据存入 HI、LO 寄存器中。</p></li><li><p>真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p><p>答：</p><ul><li><p>乘法</p><p>32位被乘数寄存器(简称A)初始化为乘法运算的被乘数，64位积寄存器 (简称B)高32位置零，用来存放乘积，低32位初始化为乘数。进行32次迭代，对于每次迭代：</p><img src="/2023/03/22/buaa-co-2022-p6/CPU%E4%B9%98%E6%B3%95.png" class="" title="CPU乘法"><p>有符号乘法只需另外计算符号位即可</p></li><li><p>除法</p><p>32位商寄存器全部置零，32位除数寄存器填充32位除数，65位余数寄存器左半部分置零，右半部分填充32位被除数。处理结构图：</p><img src="/2023/03/22/buaa-co-2022-p6/CPU%E9%99%A4%E6%B3%95.png" class="" title="CPU除法"><p>有符号除法只需另外计算符号位即可</p></li></ul></li><li><p>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</p><p>答： $mult,multu,div,divu$ 指令会让乘除法模块产生有效一个时钟周期的 $start$ 信号和相应的有效 5 或 10 个周期的 $busy$ 信号，当 $HILO_BUSY = start | busy$ 有效时，会让乘除法指令在 $NPC$ 、 $D_REG$ 模块阻塞一个周期，并清空 $E_REG$ 。</p></li><li><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p><p>答：从清晰性来说，采用字节使能信号能够清晰地显示当前指令要写哪些字节；从统一性来说，字节使能信号将写使能信号和字节控制信号统一起来，使得写宽度不同的指令可以共用该信号。</p></li><li><p>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p><p>答：在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据并不是一字节，而是一字。当 DM 的单位容量不为 $32bits$ ，而是 $8bits$ 时，按字节读写的效率高于按字读写。</p></li><li><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p><p>答：将各种控制信号的不同取值用宏来表示，而且这些宏的命名带有其对应的控制信号名。这样能够直观地识别、读写各个控制信号的取值以及含义。</p></li><li><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>答：和P5一样，不同指令的 $T_{use}$ 与 $ T_{new}$ 不同，产生不同的冲突。利用条件转发来解决。</p></li><li><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p><p>答：手动构造样例，根据转发时发送数据和接收数据的流水级寄存器不同，来构造不同类型的测试样例。</p></li></ol><p><img src="/2023/03/22/buaa-co-2022-p6/OneDrive\桌面\image-20221129210349123.png" alt="image-20221129210349123"></p><table><thead><tr><th>格式</th><th>jap target</th></tr></thead><tbody><tr><td>描述</td><td>跳转并将PC推到栈顶</td></tr></tbody></table><p>I : </p><p> vAddr ← GPR[29] </p><p> Memory[vAddr] ← PC + 8 </p><p> GPR[29] ← GPR[29] - 4 </p><p>I + 1 : </p><p> PC ← PC31…28||target||02 </p><p>执行时间为 3 个时钟周期，其他行为与 DIV 指令相同            </p><p>lwmx rs, offset(base)                </p><p>内存值大于寄存器值时写入5号寄存器，否则写入4号寄存器                </p><p>Vaddr ← GPR[base] + sign_extend(offset)</p><p>Condition ← GPR[rt] &lt; Memory[Vaddr] </p><p>If condition:</p><p>GPR[5] ← Memory[Vaddr]</p><p>else:</p><p>GPR[4] ← Memory[Vaddr]</p><table><thead><tr><th>示例</th><th>lwmx $t5, (-100)$t1</th></tr></thead><tbody><tr><td>其他</td><td>地址不是4的倍数时强制对齐。比大小是有符号数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_CO_2022 P5</title>
      <link href="/2023/03/21/buaa-co-2022-p5/"/>
      <url>/2023/03/21/buaa-co-2022-p5/</url>
      
        <content type="html"><![CDATA[<h1 id="P5-CPU"><a href="#P5-CPU" class="headerlink" title="P5_CPU"></a>P5_CPU</h1><hr><h2 id="流水线架构"><a href="#流水线架构" class="headerlink" title="流水线架构"></a>流水线架构</h2><table><thead><tr><th>阶段</th><th>简称</th><th>功能概述</th></tr></thead><tbody><tr><td>取指阶段（Fetch）</td><td>F</td><td>从指令存储器中读取指令</td></tr><tr><td>译码阶段（Decode）</td><td>D</td><td>从寄存器文件中读取源操作数并对指令译码以便得到控制信号</td></tr><tr><td>执行阶段（Execute）</td><td>E</td><td>使用 ALU 执行计算</td></tr><tr><td>存储阶段（Memory）</td><td>M</td><td>读或写数据存储器</td></tr><tr><td>写回阶段（Writeback）</td><td>W</td><td>将结果写回到寄存器文件</td></tr></tbody></table><ul><li>流水线寄存器以其供给数据的流水级的简称命名</li></ul><h3 id="取指阶段（Fetch）"><a href="#取指阶段（Fetch）" class="headerlink" title="取指阶段（Fetch）"></a>取指阶段（Fetch）</h3><h4 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h4><p>这里的 $PC$ 采用下面这种方式直接<strong>在顶层模块 $mips$ 中</strong>实现：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> PC<span class="token punctuation">;</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>    PC <span class="token operator">=</span> <span class="token number">32'h00003000</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>        PC <span class="token operator">&lt;=</span> <span class="token number">32'h00003000</span><span class="token punctuation">;</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        PC <span class="token operator">&lt;=</span> NPC_NPC<span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="im-v"><a href="#im-v" class="headerlink" title="im.v"></a>im.v</h4><h5 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">PC</td><td align="center">当前指令地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">instr</td><td align="center">取出的指令</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="npc-v"><a href="#npc-v" class="headerlink" title="npc.v"></a>npc.v</h4><h5 id="端口定义-1"><a href="#端口定义-1" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">Stall</td><td align="center">暂停信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">当前指令地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">imm26</td><td align="center">26位立即数</td><td align="center">26</td><td align="center">I</td></tr><tr><td align="center">EXT</td><td align="center">位扩展器结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">ra</td><td align="center">寄存器的值</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">nPC_sel</td><td align="center">跳转控制信号</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">isSame</td><td align="center">相等比较信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">isNega</td><td align="center">相反比较信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">NPC</td><td align="center">下一条指令地址</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">flush</td><td align="center">清空延迟槽信号</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><ul><li>若暂停信号 $Stall$ 有效，则 $NPC$ 保持不变</li><li>若对应指令满足清空延迟槽条件，则输出清空延迟槽信号 $flush$ 为 $1$</li></ul><h4 id="d-reg-v"><a href="#d-reg-v" class="headerlink" title="d_reg.v"></a>d_reg.v</h4><h5 id="端口定义-2"><a href="#端口定义-2" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">Stall</td><td align="center">暂停信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">flush</td><td align="center">清空延迟槽</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">instr_in</td><td align="center">F级指令</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">F级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">instr_out</td><td align="center">D级指令</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">PC_out</td><td align="center">D级PC</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ul><li>若暂停信号 $Stall$ 有效，则 $instr_out$ 与 $PC_out$ 保持不变</li><li>若清空延迟槽信号 $flush$ 有效<strong>且暂停信号 $Stall$ 无效</strong>，则清空 $D$ 级寄存器</li></ul><h3 id="译码阶段（Decord）"><a href="#译码阶段（Decord）" class="headerlink" title="译码阶段（Decord）"></a>译码阶段（Decord）</h3><h4 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h4><p>当一个指令到达 $D$ 级后，我们需要将它的 $T_{use}$ 值与后面每一级的 $T_{new}$ 进行比较，并进行 $A$ 值的校验。</p><ul><li><p>当 $T_{use} ≥ T_{new}$ 时，我们可以通过<strong>转发</strong>来解决冒险 </p></li><li><p>当 $T_{use} &lt; T_{new}$ 时，我们就需要<strong>阻塞</strong>流水线</p></li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> Stall_RS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rs <span class="token operator">&lt;</span> T_new_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> A3_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_E<span class="token punctuation">)</span> <span class="token operator">|</span>                   <span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rs <span class="token operator">&lt;</span> T_new_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> A3_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>    <span class="token punctuation">(</span>rs <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> Stall_RT <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rt <span class="token operator">&lt;</span> T_new_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> A3_E<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_E<span class="token punctuation">)</span> <span class="token operator">|</span>                   <span class="token punctuation">(</span><span class="token punctuation">(</span>T_use_rt <span class="token operator">&lt;</span> T_new_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> A3_M<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RegWrite_M<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>    <span class="token punctuation">(</span>rt <span class="token operator">!=</span> <span class="token number">5'd0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">assign</span> Stall <span class="token operator">=</span> Stall_RS <span class="token operator">|</span> Stall_RT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ctrl-v"><a href="#ctrl-v" class="headerlink" title="ctrl.v"></a>ctrl.v</h4><h5 id="端口定义-3"><a href="#端口定义-3" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">op</td><td align="center">指令操作码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">funct</td><td align="center">指令功能码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">RegDst</td><td align="center">GRF写地址选择信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ExtOP</td><td align="center">位扩展控制码</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ALUSrc</td><td align="center">ALU操作数B选择信号</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">ALUOP</td><td align="center">ALU控制码</td><td align="center">4</td><td align="center">O</td></tr><tr><td align="center">RegWrite</td><td align="center">寄存器写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg</td><td align="center">寄存器写数据选择信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">storeOP</td><td align="center">数据存储器写数据控制信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">DextOP</td><td align="center">数据存储器数据扩展信号</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">nPC_sel</td><td align="center">跳转控制信号</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">T_use_rs</td><td align="center">GPR[rs]的需求时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">T_use_rt</td><td align="center">GPR[rt]的需求时间</td><td align="center">2</td><td align="center">O</td></tr></tbody></table><ul><li>这里采用了<strong>控制信号驱动型</strong>的<strong>集中式译码</strong></li></ul><h5 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h5><table><thead><tr><th align="center"></th><th align="center">add(addu)</th><th align="center">sub(subu)</th><th align="center">and(or)</th><th align="center">slt(sltu)</th><th align="center">addi(addiu)</th><th align="center">andi(ori)</th><th align="center">lui</th><th align="center">lw</th><th align="center">sw</th></tr></thead><tbody><tr><td align="center"><strong>RegDst</strong></td><td align="center">01</td><td align="center">01</td><td align="center">01</td><td align="center">01</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">X</td></tr><tr><td align="center"><strong>ExtOp</strong></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">SIGN</td><td align="center">ZERO</td><td align="center">HIGN</td><td align="center">SIGN</td><td align="center">SIGN</td></tr><tr><td align="center"><strong>ALUSrc</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center"><strong>ALUOP</strong></td><td align="center">ADD</td><td align="center">SUB</td><td align="center">AND(OR)</td><td align="center">SLT(SLTU)</td><td align="center">ADD</td><td align="center">AND(OR)</td><td align="center">ADD</td><td align="center">ADD</td><td align="center">ADD</td></tr><tr><td align="center"><strong>RegWrite</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"><strong>MemWrite</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center"><strong>MemtoReg</strong></td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">01</td><td align="center">X</td></tr><tr><td align="center"><strong>nPC_sel</strong></td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td><td align="center">PC4</td></tr><tr><td align="center"><strong>T_use_rs</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center"><strong>T_use_rt</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">2</td></tr></tbody></table><ul><li>信号 $storeOP$ 只对指令 $sw(2’d1), sh(2’d2), sb(2’d3)$ 生效，未列于表中</li><li>信号 $DextOP$ 只对指令 $lw(dext_lw), lh(dext_lh), lhu(dext_lhu), lb(dext_lb), lbu(dext_lbu)$ 生效，未列于表中</li><li>指令的需求时间 $T_{use}$ 是指这条指令位于 $D$ 级的时候，<strong>再经过多少个时钟周期就必须要使用相应的数据</strong></li><li>实际上， $T_{use}$ 的最大值为 $2’d2$ ，当指令用不到 $GPR[rs]$ 或 $GPR[rt]$ 时，我们将对应的置 $T_{use}$ 为 $2’d3$ ，这并不会影响我们对转发和暂停的判断</li></ul><h4 id="grf-v"><a href="#grf-v" class="headerlink" title="grf.v"></a>grf.v</h4><h5 id="端口定义-4"><a href="#端口定义-4" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">RegWrite</td><td align="center">寄存器写使能</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">当前指令的地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A1</td><td align="center">读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2</td><td align="center">读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A3</td><td align="center">读地址3</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">WD</td><td align="center">写数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">RD1</td><td align="center">输出A1指定的寄存器数据</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">RD2</td><td align="center">输出A2指定的寄存器数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="ext-v"><a href="#ext-v" class="headerlink" title="ext.v"></a>ext.v</h4><h5 id="端口定义-5"><a href="#端口定义-5" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">imm16</td><td align="center">16位立即数</td><td align="center">16</td><td align="center">I</td></tr><tr><td align="center">ExtOP</td><td align="center">位扩展控制码</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">EXT_Result</td><td align="center">位扩展结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="cmp-v"><a href="#cmp-v" class="headerlink" title="cmp.v"></a>cmp.v</h4><h5 id="端口定义-6"><a href="#端口定义-6" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">GRF_RD1</td><td align="center">GRF读数据1</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">GRF_RD2</td><td align="center">GRF读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">isSame</td><td align="center">相等比较信号</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">isNega</td><td align="center">相反比较信号</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><ul><li>这里添加一个 $CMP$ 模块是为了将**$B$ 类跳转指令的<strong>判定</strong>提前至 $D$ 级**来进行，不再使用 $E$ 级的 $ALU$ 来进行判定</li></ul><h4 id="e-reg-v"><a href="#e-reg-v" class="headerlink" title="e_reg.v"></a>e_reg.v</h4><h5 id="端口定义-7"><a href="#端口定义-7" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">Stall</td><td align="center">暂停信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">D级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">op</td><td align="center">D级指令操作码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">funct</td><td align="center">D级指令功能码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">shamt_in</td><td align="center">D级shamt</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALUSrc_in</td><td align="center">D级ALUSrc</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">ALUOP_in</td><td align="center">D级ALUOP</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">RegWrite_in</td><td align="center">D级RegWrite</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemtoReg_in</td><td align="center">D级MemtoReg</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">storeOP_in</td><td align="center">D级storeOP</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">DextOP_in</td><td align="center">D级DextOP</td><td align="center">3</td><td align="center">I</td></tr><tr><td align="center">A1_in</td><td align="center">D级寄存器读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2_in</td><td align="center">D级寄存器读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">GRF_RD1_in</td><td align="center">D级寄存器读数据1</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">GRF_RD2_in</td><td align="center">D级寄存器读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A3_in</td><td align="center">D级寄存器写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">EXT_Result_in</td><td align="center">D级位扩展结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_out</td><td align="center">E级PC</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">shamt_out</td><td align="center">E级shamt</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">T_new</td><td align="center">E级指令供给时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ALUSrc_out</td><td align="center">E级ALUSrc</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">ALUOP_out</td><td align="center">E级ALUOP</td><td align="center">4</td><td align="center">O</td></tr><tr><td align="center">RegWrite_out</td><td align="center">E级RegWrite</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg_out</td><td align="center">E级MemtoReg</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">storeOP</td><td align="center">E级storeOP</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">DextOP</td><td align="center">E级DextOP</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">A1_out</td><td align="center">E级寄存器读地址1</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">A2_out</td><td align="center">E级寄存器读地址2</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">GRF_RD1_out</td><td align="center">E级寄存器读数据1</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">GRF_RD2_out</td><td align="center">E级寄存器读数据2</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">A3_out</td><td align="center">E级寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">EXT_Result_out</td><td align="center">E级位扩展结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ul><li>指令的供给时间 $T_{new}$ 是指位于<strong>某个流水级</strong>的<strong>某个指令</strong>，它经过多少个时钟周期可以算出结果并且<strong>存储到流水级寄存器里</strong></li><li>若暂停信号 $Stall$ 有效，则清空 $E_REG$ (效果同 $reset$ )</li></ul><h3 id="执行阶段（Excute）"><a href="#执行阶段（Excute）" class="headerlink" title="执行阶段（Excute）"></a>执行阶段（Excute）</h3><h4 id="alu-v"><a href="#alu-v" class="headerlink" title="alu.v"></a>alu.v</h4><h5 id="端口定义-8"><a href="#端口定义-8" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">操作数A</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">B</td><td align="center">操作数B</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">shamt</td><td align="center">移位数</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALUOp</td><td align="center">ALU控制码</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">C</td><td align="center">运算结果</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">isZero</td><td align="center">零判断</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><h4 id="m-meg-v"><a href="#m-meg-v" class="headerlink" title="m_meg.v"></a>m_meg.v</h4><h5 id="端口定义-9"><a href="#端口定义-9" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">E级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">T_new_in</td><td align="center">E级指令供给时间</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">RegWrite_in</td><td align="center">E级RegWrite</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemtoReg_in</td><td align="center">E级MemtoReg</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">storeOP_in</td><td align="center">E级storeOP</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">DextOP_in</td><td align="center">E级DextOP</td><td align="center">3</td><td align="center">I</td></tr><tr><td align="center">A1_in</td><td align="center">E级寄存器读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2_in</td><td align="center">E级寄存器读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A3_in</td><td align="center">E级寄存器写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALU_C_in</td><td align="center">E级ALU计算结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">GRF_RD2_in</td><td align="center">E级寄存器读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_out</td><td align="center">M级PC</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">T_new_out</td><td align="center">M级指令供给时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">RegWrite_out</td><td align="center">M级RegWrite</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg_out</td><td align="center">M级MemtoReg</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">storeOP_out</td><td align="center">M级storeOP</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">DextOP_out</td><td align="center">M级DextOP</td><td align="center">3</td><td align="center">O</td></tr><tr><td align="center">A1_out</td><td align="center">M级寄存器读地址1</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">A2_out</td><td align="center">M级寄存器读地址2</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">A3_out</td><td align="center">M级寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">ALU_C_out</td><td align="center">M级ALU计算结果</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">GRF_RD2_out</td><td align="center">M级寄存器读数据2</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h3 id="存储阶段（Memory"><a href="#存储阶段（Memory" class="headerlink" title="存储阶段（Memory)"></a>存储阶段（Memory)</h3><h4 id="dm-v"><a href="#dm-v" class="headerlink" title="dm.v"></a>dm.v</h4><h5 id="端口定义-10"><a href="#端口定义-10" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">M级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A</td><td align="center">数据存储器读写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">WD</td><td align="center">DM写数据</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">byteen</td><td align="center">数据存储器字节写使能</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">RD</td><td align="center">DM读数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ul><li>这里可以用 $|byteen$ 来代替原先的数据存储器写使能信号 $MemWrite$</li></ul><h4 id="w-reg-v"><a href="#w-reg-v" class="headerlink" title="w_reg.v"></a>w_reg.v</h4><h5 id="端口定义-11"><a href="#端口定义-11" class="headerlink" title="端口定义"></a>端口定义</h5><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC_in</td><td align="center">M级PC</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">T_new_in</td><td align="center">M级指令供给时间</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">RegWrite_in</td><td align="center">M级RegWrite</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemtoReg_in</td><td align="center">M级MemtoReg</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">A3_in</td><td align="center">M级寄存器写地址</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALU_C_in</td><td align="center">M级ALU计算结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">DM_RD_in</td><td align="center">M级DM读数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC_out</td><td align="center">W级PC</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">T_new_out</td><td align="center">W级指令供给时间</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">RegWrite_out</td><td align="center">W级RegWrite</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg_out</td><td align="center">W级MemtoReg</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">A3_out</td><td align="center">W级寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr><tr><td align="center">ALU_C_out</td><td align="center">W级ALU计算结果</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">DM_RD_out</td><td align="center">W级DM读数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h2 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h2><h3 id="冒险的种类"><a href="#冒险的种类" class="headerlink" title="冒险的种类"></a>冒险的种类</h3><h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p>结构冒险是指<strong>不同指令同时需要使用同一资源</strong>的情况。例如在普林斯顿结构中，指令存储器和数据存储器是同一存储器，在取指阶段和存储阶段都需要使用这个存储器，这时便产生了结构冒险。我们的实验采用哈佛体系结构，将指令存储器和数据存储器分开，因此不存在这种结构冒险。</p><p>另一种结构冒险在于寄存器文件需要在 $D$ 级和 $W$ 级同时被使用（读写）时并且读和写的寄存器为同一个寄存器时。</p><h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>控制冒险，是指<strong>分支指令（如 $beq$ ）的判断结果会影响接下来指令的执行流</strong>的情况。在判断结果产生之前，我们无法预测分支是否会发生。然而，此时流水线还会继续取指，让后续指令进入流水线。这时就有可能导致错误的产生，即不该被执行的指令进入到了指令的执行流中。</p><h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>流水线之所以会产生数据冒险，就是因为后面指令需求的数据，正好就是前面指令供给的数据，而后面指令在需要使用数据时，前面供给的数据还没有存入寄存器堆，从而导致后面的指令不能正常地读取到正确的数据。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><em>1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</em></p><p>答：将分支判断提前至 $D$ 级进行时，我们常常需要利用 $E$ 级 $ALU$ 计算的结果，而这个结果在下一个周期才能存入 $E$ 级寄存器，这时会使得流水线被<strong>阻塞</strong>一个周期，流水线的效率受到了一定的影响。</p><pre class="line-numbers language-none"><code class="language-none">ori  $t0, $0, 0x1beq  $t0, $0, loopnoploop:...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</em></p><p>答：因为地址为 $PC + 4$ 的指令位于延迟槽中，一定会被执行，跳转时要跳转到的指令地址为其后一条指令，即地址为 $PC + 8$ 的指令。</p><p><em>3、我们要求大家所有转发数据都来源于<strong>流水寄存器</strong>而不能是功能部件（如 DM 、 ALU ），请思考为什么？</em></p><p>答：若不这样做，会导致我们的流水线不能正常地<strong>并行</strong>运行，而是会将某两个流水级<strong>串行</strong>运行。这样降低了流水线工作的效率。</p><p><em>4、我们为什么要使用 GPR 内部转发？该如何实现？</em></p><p>答：因为 $GPR$ 既属于 $D$ 级，也属于 $W$ 级。当一条指令在 $D$ 级需要读出寄存器内的数据时，若此时位于 W 级的指令正在写寄存器，就可以利用 $GPR$ 的内部转发将这个写数据直接读出。</p><p><em>5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</em></p><p>答：需求者可能来源于 $D$ 、 $E$ 、 $M$ 级，供给者可能来源于 $E$ 、 $M$ 、 $W$ 级。</p><p>转发数据通路有： $D &lt;- E$ , $D &lt;- M$ , $D &lt;- W$ , $E &lt;- M$ , $E &lt;- W$ , $M &lt;- W$ 。</p><p><em>6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</em></p><p>答：课上指令大致可以分为计算类指令、条件跳转类指令、条件访存类指令。</p><ul><li><p>对于计算类指令，一般情况下只需要在译码时添加一个 $ALUOp$ ，在 $ALU$ 中来实现其运算操作即可。</p></li><li><p>对于条件跳转类指令，可以在译码时添加一个 $nPC_sel$ ，在 $NPC$ 模块中实现其对应的 $NPC$ 值，必要时应在 $NPC$ 以及 $CMP$ 模块中加入一些控制信号来辅助判断。比如可以添加 $flush$ 信号来判断是否需要清空延迟槽。</p></li><li><p>对于条件访存类指令，可能会增加 $GPR[rs]$ 值的流水，可能会因为写入的不确定性导致转发数据需要额外的判断。</p></li></ul><p><em>7、简要描述你的译码器架构，并思考该架构的优势以及不足。</em></p><p>答：我的译码器采用的是<strong>控制信号驱动型</strong>的<strong>集中式译码</strong>。</p><p>优势为只需要在 $D$ 级进行一次译码即可，比较简单粗暴，且指令数较多时代码量不见得很多。</p><p>不足为后续每一级流水级寄存器都要传递大量的控制信号，写起来比较繁琐复杂<del>（已经深刻体会到了）</del>。</p><h2 id="课上指令"><a href="#课上指令" class="headerlink" title="课上指令"></a>课上指令</h2><h3 id="BONALL"><a href="#BONALL" class="headerlink" title="BONALL"></a>BONALL</h3><p>先<strong>链接</strong>。如果 $GPR[rs]$ 和 $GPR[rt]$ 互为相反数，则跳转，否则<strong>清空延迟槽</strong>。</p><pre class="line-numbers language-none"><code class="language-none">ori  $7, $0, 0x1ori  $8, $0, 0x2sub  $9, $7, $8beq  $9, $7, loop1ori  $10, $0, 0x9999ori  $10, $0, 0x8888loop1:ori  $10, $0, 0x7777nopnopnopbeq  $9, $8, loop2ori  $11, $0, 0x9999ori  $11, $0, 0x8888loop2:ori  $11, $0, 0x7777nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="由补码求原码"><a href="#由补码求原码" class="headerlink" title="由补码求原码"></a>由补码求原码</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token kernel-function property">$signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    Result <span class="token operator">=</span> A<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> <span class="token number">32'b0</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>    Result <span class="token operator">=</span> <span class="token number">32'h8000_0000</span><span class="token punctuation">;</span> <span class="token keyword">end</span><span class="token keyword">else</span> <span class="token keyword">begin</span>    Result <span class="token operator">=</span> <span class="token operator">{</span>A<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">31'h1</span><span class="token punctuation">)</span><span class="token operator">}</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>接收新数据的流水级&lt;-发射新数据的流水级</p><h3 id="M-lt-W"><a href="#M-lt-W" class="headerlink" title="M <- W"></a>M &lt;- W</h3><p>M级要接收数据：</p><ul><li>FW_DM_WD_out</li></ul><p>W级可发射数据：</p><ul><li>PC_W + 32’h8</li><li>ALU_C_W</li></ul><h3 id="E-lt-W"><a href="#E-lt-W" class="headerlink" title="E <- W"></a>E &lt;- W</h3><p>E级要接收数据：</p><ul><li>FW_ALUA_out</li><li>FW_ALUB_out</li></ul><p>W级可发射数据：</p><ul><li>PC_W + 32’h8</li><li>ALU_C_W</li></ul><h3 id="D-lt-W"><a href="#D-lt-W" class="headerlink" title="D <- W"></a>D &lt;- W</h3><p>D级要接收数据：</p><ul><li>FW_RD1_out</li><li>FW_RD2_out</li></ul><p>W级可发射数据：</p><ul><li>PC_W + 32’h8</li><li>ALU_C_W</li></ul><h3 id="E-lt-M"><a href="#E-lt-M" class="headerlink" title="E <- M"></a>E &lt;- M</h3><p>E级要接收数据：</p><ul><li>FW_ALUA_out</li><li>FW_ALUB_out</li></ul><p>M级可发射数据：</p><ul><li>PC_M + 32’h8</li><li>ALU_C_M</li></ul><h3 id="D-lt-M"><a href="#D-lt-M" class="headerlink" title="D <- M"></a>D &lt;- M</h3><p>D级要接收数据：</p><ul><li>FW_RD1_out</li><li>FW_RD2_out</li></ul><p>M级可发射数据：</p><ul><li>PC_M + 32’h8</li><li>ALU_C_M</li></ul><h3 id="D-lt-E"><a href="#D-lt-E" class="headerlink" title="D <- E"></a>D &lt;- E</h3><p>D级要接收数据：</p><ul><li>FW_RD1_out</li><li>FW_RD2_out</li></ul><p>E级可发射数据：</p><ul><li>PC_E + 32’h8</li><li>EXT_Result_E</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-MIPS" data-language="MIPS"><code class="language-MIPS">######## M &lt;- W ########## FW_DM_WD_out &lt;- ALU_C_Wori $t1, $0, 0x1nopnopnopadd $t1, $t1, $t1sw $t1, 0($0)nopnopnop# FW_DM_WD_out &lt;- PC_W + 32'h8ori $t1, $0, 0x1nopnopnopjal test_m_wsw $ra, 0($0)ori $t1, $0, 0x2j test_m_w_endnoptest_m_w:ori $t1, $0, 0x3jr $ranopnopnoptest_m_w_end:nopnopnop######## E &lt;- W ########## FW_ALU_out &lt;- ALU_C_Wori $t1, $0, 0x1nopnopnopadd $t2, $t1, $t1nopadd $t3, $t2, $t2nopnopnop# FW_ALU_out &lt;- PC_W + 32'h8jal test_e_wnopj test_e_w_endnoptest_e_w:add $t4, $ra, $ranopnopnopjr $ranoptest_e_w_end:nopnopnop########## D &lt;- W ########## FW_RD12_out &lt;- ALU_C_Wori $t1, $0, 0x1111nopnopnopori $t2, $0, 0x2222nopnopnopadd $t3, $t1, $t1 # Wnop # Mnop # Ebeq $t3, $t2, test_d_w_1 # Dnopori $t1, $0, 0x3333test_d_w_1:ori $t1, $0, 0x1111nopnopnop######add $t4, $t1, $t1 # Wnop # Mnop # Ebeq $t2, $t4, test_d_w_2 # Dnopori $t1, $0, 0x5555test_d_w_2:ori $t1, $0, 0x6666nopnopnop# FW_RD12_out &lt;- PC_W + 32'h8ori $t5, $0, 0x314cnopnopnopjal test_d_w # Wnop # Mj test_d_w_endnoptest_d_w:nop # Ebeq $ra, $t5, test_d_w_3 # Dnopori $t1, $0, 0x3333test_d_w_3:nopnopnopjr $ranoptest_d_w_end:nopnopnop########### E &lt;- M ############ FW_ALU_out &lt;- ALU_C_Mori $t1, $0, 0x1nopnopnopadd $t2, $t1, $t1 # Madd $t3, $t2, $t2 # Enopnopnop# FW_ALU_out &lt;- PC_M + 32'h8jal test_e_m # Madd $t1, $ra, $ra # Ej test_e_m_endnoptest_e_m:nopnopnopjr $ranoptest_e_m_end:nopnopnop########## D &lt;- M ############ FW_RD12_out &lt;- ALU_C_Mori $t1, $0, 0x1111nopnopnopori $t2, $0, 0x2222nopnopnopori $t3, $0, 0nopnopnopadd $t3, $t1, $t1 # Mnop # Ebeq $t3, $t2, test_d_m_1 # Dnopori $t1, $0, 0x3333test_d_m_1:ori $t1, $0, 0x1111nopnopnop######add $t4, $t1, $t1 # Mnop # Ebeq $t2, $t4, test_d_m_2 # Dnopori $t1, $0, 0x5555test_d_m_2:ori $t1, $0, 0x6666nopnopnop# FW_RD12_out &lt;- PC_M + 32'h8ori $t5, $0, 0x3268nopnopnopjal test_d_m # Mnop # Ej test_d_m_endnoptest_d_m:beq $ra, $t5, test_d_m_3 # Dnopori $t1, $0, 0x3333test_d_m_3:nopnopnopjr $ranoptest_d_m_end:nopnopnop########### D &lt;- E ############ FW_RD12_out &lt;- EXT_Result_Elui $t1, 0x9nopnopnoplui $t2, 0x9 # E beq $t1, $t2, test_d_e_1nopori $t1, $0, 0x3333test_d_e_1:nopnopnop# FW_RD12_out &lt;- PC_M + 32'h8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_CO_2022_P4</title>
      <link href="/2023/03/21/buaa-co-2022-p4/"/>
      <url>/2023/03/21/buaa-co-2022-p4/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU设计文档"><a href="#CPU设计文档" class="headerlink" title="CPU设计文档"></a>CPU设计文档</h1><hr><h2 id="ctrl模块"><a href="#ctrl模块" class="headerlink" title="ctrl模块"></a>ctrl模块</h2><h3 id="ctrl-v"><a href="#ctrl-v" class="headerlink" title="ctrl.v"></a>ctrl.v</h3><h4 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">op</td><td align="center">指令操作码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">funct</td><td align="center">指令功能码</td><td align="center">6</td><td align="center">I</td></tr><tr><td align="center">RegDst</td><td align="center">GRF写地址选择信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ALUSrc</td><td align="center">ALU操作数B选择信号</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemtoReg</td><td align="center">寄存器写数据选择信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">RegWrite</td><td align="center">寄存器写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">MemWrite</td><td align="center">数据存储器写使能</td><td align="center">1</td><td align="center">O</td></tr><tr><td align="center">nPC_sel</td><td align="center">跳转控制信号</td><td align="center">2</td><td align="center">O</td></tr><tr><td align="center">ALUOp</td><td align="center">ALU控制码</td><td align="center">4</td><td align="center">O</td></tr><tr><td align="center">ExtOp</td><td align="center">位扩展控制码</td><td align="center">2</td><td align="center">O</td></tr></tbody></table><h4 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h4><table><thead><tr><th align="center"></th><th align="center">add</th><th align="center">sub</th><th align="center">ori</th><th align="center">lw</th><th align="center">sw</th><th align="center">beq</th><th align="center">lui</th><th align="center">jal</th><th align="center">jr</th></tr></thead><tbody><tr><td align="center"><strong>RegDst</strong></td><td align="center">01</td><td align="center">01</td><td align="center">00</td><td align="center">00</td><td align="center">X</td><td align="center">X</td><td align="center">00</td><td align="center">10</td><td align="center">X</td></tr><tr><td align="center"><strong>ALUSrc</strong></td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>MemtoReg</strong></td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">01</td><td align="center">X</td><td align="center">X</td><td align="center">00</td><td align="center">10</td><td align="center">X</td></tr><tr><td align="center"><strong>RegWrite</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"><strong>MemWrite</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><strong>nPC_sel</strong></td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">01</td><td align="center">00</td><td align="center">10</td><td align="center">11</td></tr><tr><td align="center"><strong>ALUctr</strong></td><td align="center">ADD</td><td align="center">SUB</td><td align="center">OR</td><td align="center">ADD</td><td align="center">ADD</td><td align="center">SUB</td><td align="center">ADD</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>ExtOp</strong></td><td align="center">X</td><td align="center">X</td><td align="center">Zero</td><td align="center">Sign</td><td align="center">Sign</td><td align="center">Sign</td><td align="center">High</td><td align="center">X</td><td align="center">X</td></tr></tbody></table><h2 id="Datapath模块"><a href="#Datapath模块" class="headerlink" title="Datapath模块"></a>Datapath模块</h2><h3 id="grf-v"><a href="#grf-v" class="headerlink" title="grf.v"></a>grf.v</h3><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">RegWrite</td><td align="center">寄存器写使能</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">当前指令的地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A1</td><td align="center">读地址1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A2</td><td align="center">读地址2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A3</td><td align="center">读地址3</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">WD</td><td align="center">写数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">RD1</td><td align="center">输出A1指定的寄存器数据</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">RD2</td><td align="center">输出A2指定的寄存器数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h3 id="alu-v"><a href="#alu-v" class="headerlink" title="alu.v"></a>alu.v</h3><h4 id="端口定义-1"><a href="#端口定义-1" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">操作数A</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">B</td><td align="center">操作数B</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">shamt</td><td align="center">移位数</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">ALUOp</td><td align="center">ALU控制码</td><td align="center">4</td><td align="center">I</td></tr><tr><td align="center">C</td><td align="center">运算结果</td><td align="center">32</td><td align="center">O</td></tr><tr><td align="center">isZero</td><td align="center">零判断</td><td align="center">1</td><td align="center">O</td></tr></tbody></table><h4 id="ALU控制码"><a href="#ALU控制码" class="headerlink" title="ALU控制码"></a>ALU控制码</h4><table><thead><tr><th align="center">ALUop</th><th align="center">Function</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">ADD</td></tr><tr><td align="center">0001</td><td align="center">SUB</td></tr><tr><td align="center">0010</td><td align="center">OR</td></tr><tr><td align="center">0011</td><td align="center">AND</td></tr><tr><td align="center">0100</td><td align="center">XOR</td></tr></tbody></table><h3 id="ext-v"><a href="#ext-v" class="headerlink" title="ext.v"></a>ext.v</h3><h4 id="端口定义-2"><a href="#端口定义-2" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">imm16</td><td align="center">16位立即数</td><td align="center">16</td><td align="center">I</td></tr><tr><td align="center">ExtOp</td><td align="center">位扩展控制码</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">Result</td><td align="center">位扩展结果</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="位扩展控制码"><a href="#位扩展控制码" class="headerlink" title="位扩展控制码"></a>位扩展控制码</h4><table><thead><tr><th align="center">ExtOp</th><th align="center">Function</th></tr></thead><tbody><tr><td align="center">00</td><td align="center">Zero</td></tr><tr><td align="center">01</td><td align="center">Sign</td></tr><tr><td align="center">10</td><td align="center">High</td></tr><tr><td align="center">11</td><td align="center">?</td></tr></tbody></table><h3 id="im-v"><a href="#im-v" class="headerlink" title="im.v"></a>im.v</h3><h4 id="端口定义-3"><a href="#端口定义-3" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">PC</td><td align="center">当前指令地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">instr</td><td align="center">取出的指令</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h3 id="dm-v"><a href="#dm-v" class="headerlink" title="dm.v"></a>dm.v</h3><h4 id="端口定义-4"><a href="#端口定义-4" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">clk</td><td align="center">时钟信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">reset</td><td align="center">同步复位信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">MemWrite</td><td align="center">数据存储器写使能</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">PC</td><td align="center">当前指令地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">A</td><td align="center">读地址</td><td align="center">10</td><td align="center">I</td></tr><tr><td align="center">WD</td><td align="center">写数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">RD</td><td align="center">输出A指定地址的数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h3 id="npc-v"><a href="#npc-v" class="headerlink" title="npc.v"></a>npc.v</h3><h4 id="端口定义-5"><a href="#端口定义-5" class="headerlink" title="端口定义"></a>端口定义</h4><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">PC</td><td align="center">当前指令地址</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">imm26</td><td align="center">26位立即数</td><td align="center">26</td><td align="center">I</td></tr><tr><td align="center">EXT</td><td align="center">位扩展器结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">ra</td><td align="center"><code>$ra</code>寄存器的值</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">nPC_sel</td><td align="center">跳转控制信号</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">isZero</td><td align="center">零判断信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">NPC</td><td align="center">下一条指令地址</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h4 id="跳转控制信号"><a href="#跳转控制信号" class="headerlink" title="跳转控制信号"></a>跳转控制信号</h4><table><thead><tr><th align="center">nPC_sel</th><th align="center">NPC</th></tr></thead><tbody><tr><td align="center">00</td><td align="center">PC + 4</td></tr><tr><td align="center">01</td><td align="center">(isZero == 1’b1) ? PC + 4 + (EXT &lt;&lt; 2) : PC + 4</td></tr><tr><td align="center">10</td><td align="center">{PC[31:28], imm26 &lt;&lt; 2}</td></tr><tr><td align="center">11</td><td align="center">GPR[rs]</td></tr></tbody></table><h3 id="mux-v"><a href="#mux-v" class="headerlink" title="mux.v"></a>mux.v</h3><h4 id="端口定义-6"><a href="#端口定义-6" class="headerlink" title="端口定义"></a>端口定义</h4><ul><li>mux_A3</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">RegDst</td><td align="center">寄存器写地址选择信号</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">rt</td><td align="center">源操作数寄存器1</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">rd</td><td align="center">源操作数寄存器2</td><td align="center">5</td><td align="center">I</td></tr><tr><td align="center">A3</td><td align="center">寄存器写地址</td><td align="center">5</td><td align="center">O</td></tr></tbody></table><ul><li>mux_ALUB</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">ALUSrc</td><td align="center">ALU操作数B选择信号</td><td align="center">1</td><td align="center">I</td></tr><tr><td align="center">RD2</td><td align="center">寄存器读数据2</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">imm</td><td align="center">经位扩展后的立即数</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">B</td><td align="center">ALU操作数B</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><ul><li>mux_grf_WD</li></ul><table><thead><tr><th align="center">名称</th><th align="center">描述</th><th align="center">位宽</th><th align="center">方向</th></tr></thead><tbody><tr><td align="center">MemtoReg</td><td align="center">寄存器写数据选择信号</td><td align="center">2</td><td align="center">I</td></tr><tr><td align="center">C</td><td align="center">ALU运算结果</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">RD</td><td align="center">数据存储器读数据</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">PC4</td><td align="center">PC + 4</td><td align="center">32</td><td align="center">I</td></tr><tr><td align="center">WD</td><td align="center">GRF写数据</td><td align="center">32</td><td align="center">O</td></tr></tbody></table><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><em>1.阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</em></p><img src="/2023/03/21/buaa-co-2022-p4/Picture1.png" class="" title="Picture1"><p>addr信号来源于指令。</p><p>在DM中，我们需要按字寻址，而MIPS架构中是按字节寻址的，所以应取addr[11:2]而不是[9:0]。</p><p><em>2.思考上述两种控制器设计的译码方式（记录下<strong>指令对应的控制信号如何取值</strong>或记录下<strong>控制信号每种取值所对应的指令</strong>），给出代码示例，并尝试对比各方式的优劣。</em></p><ul><li>记录下指令对应的控制信号如何取值</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">case</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span>    lw <span class="token punctuation">:</span> <span class="token keyword">begin</span>        <span class="token keyword">assign</span> RegDst <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> ALUSrc <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> MemtoReg <span class="token operator">=</span> <span class="token number">2'b01</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> RegWrite <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> MemWrite <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token comment">//......</span>    <span class="token keyword">end</span>        sw <span class="token punctuation">:</span> <span class="token keyword">begin</span>        <span class="token keyword">assign</span> RegDst <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> ALUSrc <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> MemtoReg <span class="token operator">=</span> <span class="token number">2'b00</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> RegWrite <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">assign</span> MemWrite <span class="token operator">=</span> <span class="token number">1'b1</span><span class="token punctuation">;</span>        <span class="token comment">//......</span>    <span class="token keyword">end</span><span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法可以清晰地看到每条指令所对应的各个控制信号的取值。但如果有新增的控制信号，需要在每条指令下都添加新增控制信号的取值情况，当指令数量较多时会很不方便。</p><ul><li>记录下控制信号每种取值所对应的指令</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> RegDst <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> special <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>funct <span class="token operator">==</span> add <span class="token operator">||</span> funct <span class="token operator">==</span> sub<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b01</span> <span class="token punctuation">:</span><span class="token punctuation">(</span>op <span class="token operator">==</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b10</span> <span class="token punctuation">:</span> <span class="token number">2'b00</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ALUSrc <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> ori <span class="token operator">||</span> op <span class="token operator">==</span> lw <span class="token operator">||</span> op <span class="token operator">==</span> sw <span class="token operator">||</span> op <span class="token operator">==</span> lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span><span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> MemtoReg <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> lw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b01</span> <span class="token punctuation">:</span>  <span class="token punctuation">(</span>op <span class="token operator">==</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b10</span> <span class="token punctuation">:</span>  <span class="token number">2'b00</span><span class="token punctuation">;</span><span class="token keyword">assign</span> RegWrite <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> ori <span class="token operator">||</span> op <span class="token operator">==</span> lw <span class="token operator">||</span> op <span class="token operator">==</span> lui <span class="token operator">||</span> op <span class="token operator">==</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span>  <span class="token punctuation">(</span>op <span class="token operator">==</span> special <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>funct <span class="token operator">==</span> add <span class="token operator">||</span> funct <span class="token operator">==</span> sub<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span>  <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> MemWrite <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> sw<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1'b1</span> <span class="token punctuation">:</span>  <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token keyword">assign</span> nPC_sel <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> beq<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b01</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> jal<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b10</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> special <span class="token operator">&amp;&amp;</span> funct <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b11</span> <span class="token punctuation">:</span> <span class="token number">2'b00</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ALUOp <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> beq<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> special <span class="token operator">&amp;&amp;</span> funct <span class="token operator">==</span> sub<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">4'b0001</span> <span class="token punctuation">:</span>   <span class="token punctuation">(</span>op <span class="token operator">==</span> ori<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">4'b0010</span> <span class="token punctuation">:</span>   <span class="token number">4'b0000</span><span class="token punctuation">;</span><span class="token keyword">assign</span> ExtOp <span class="token operator">=</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> lw <span class="token operator">||</span> op <span class="token operator">==</span> sw <span class="token operator">||</span> op <span class="token operator">==</span> beq<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b01</span> <span class="token punctuation">:</span>   <span class="token punctuation">(</span>op <span class="token operator">==</span> lui<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2'b10</span> <span class="token punctuation">:</span>   <span class="token number">2'b00</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法可以清晰地看到每条控制信号在不同取值时对应的指令都有哪些，且新增控制信号较为方便。但在查看某条指令对应的控制信号时并不直观。</p><p><em>3.在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与 P3 中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的 reset 信号与 clk 信号优先级的关系。</em></p><p>同步复位：<strong>只有在clk上升沿</strong>才会判断reset信号是否有效，其余情况下无论reset是否有效，都不会进行复位；</p><p>异步复位：<strong>在任何时候</strong>只要reset有效，无论clk为何值，立即进行复位操作。</p><p><em>4.C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C  语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。  请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32®  Architecture For Programmers Volume II: The MIPS32® Instruction  Set》中相关指令的 Operation 部分 。</em></p><p>指令集中显示，ADDU(ADDIU)是直接将运算结果存入rd(rt)对应的寄存器中，而ADD(ADDI)是先判断是否溢出，若溢出则抛出异常，否则将结果存入rd(rt)对应的寄存器中。</p><p>如果忽略溢出，那么ADDU(ADDIU)和ADD(ADDI)产生的结果均为将运算结果存入rd(rt)对应的寄存器中，所以是等价的。</p><h2 id="CPU-Logisim"><a href="#CPU-Logisim" class="headerlink" title="CPU_Logisim"></a>CPU_Logisim</h2><img src="/2023/03/21/buaa-co-2022-p4/CPU_P1.png" class="" title="CPU_P1"><img src="/2023/03/21/buaa-co-2022-p4/CPU_P2.png" class="" title="CPU_P2">]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_CO_2022_P3</title>
      <link href="/2023/03/21/buaa-co-2022-p3/"/>
      <url>/2023/03/21/buaa-co-2022-p3/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-设计文档"><a href="#CPU-设计文档" class="headerlink" title="CPU 设计文档"></a>CPU 设计文档</h1><hr><h2 id="CPU模块设计"><a href="#CPU模块设计" class="headerlink" title="CPU模块设计"></a>CPU模块设计</h2><h3 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h3><h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><ul><li><code>PC[31:0]</code></li><li><code>imm26[25:0]</code></li><li><code>EXT_IMM16[31:0]</code></li><li><code>GPR[rs][31:0]</code></li><li><code>nPC_sel[1:0]</code></li><li><code>isZero</code></li></ul><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ul><li><code>NPC[31:0]</code></li></ul><h3 id="IM-指令存储器"><a href="#IM-指令存储器" class="headerlink" title="IM(指令存储器)"></a>IM(指令存储器)</h3><h4 id="输入与输出-1"><a href="#输入与输出-1" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h5><ul><li><code>PC[31:0]</code></li></ul><h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><ul><li>指令<code>Instruction[31:0]</code></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>这里使用到的存储器是ROM存储器，ROM是只读存储器，具有非易失性</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>实际地址宽度为5位，所以ROM的Address Bit Width应设置为5  </p></li><li><p>向ROM中读指令时，文件头应为：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">v2.0 raw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="DM-数据存储器"><a href="#DM-数据存储器" class="headerlink" title="DM(数据存储器)"></a>DM(数据存储器)</h3><h4 id="输入与输出-2"><a href="#输入与输出-2" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h5><ul><li>写地址<code>Addr[31:0]</code></li><li>写入数据<code>WD[31:0]</code></li><li>写使能信号<code>MemWrite</code></li><li><code>MemtoReg</code></li><li>异步复位信号<code>reset</code></li></ul><h5 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h5><ul><li>数据输出<code>RD[31:0]</code></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul><li>这里使用的存储器是RAM</li></ul><h3 id="ALU-算术逻辑单元"><a href="#ALU-算术逻辑单元" class="headerlink" title="ALU(算术逻辑单元)"></a>ALU(算术逻辑单元)</h3><h4 id="输入与输出-3"><a href="#输入与输出-3" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h5><ul><li>运算数<code>A[31:0]</code></li><li>运算数<code>B[31:0]</code></li><li>ALU控制码<code>ALUop[3:0]</code></li></ul><h5 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h5><ul><li>运算结果<code>Result[31:0]</code></li><li>零判断<code>isZero</code></li></ul><h4 id="ALU控制码"><a href="#ALU控制码" class="headerlink" title="ALU控制码"></a>ALU控制码</h4><p>根据ALU控制码<code>ALUop</code>来确定进行何种运算：  </p><table><thead><tr><th align="center">ALUop</th><th align="center">Function</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">ADD</td></tr><tr><td align="center">0001</td><td align="center">SUB</td></tr><tr><td align="center">0010</td><td align="center">OR</td></tr><tr><td align="center">0011</td><td align="center">AND</td></tr><tr><td align="center">0100</td><td align="center">XOR</td></tr></tbody></table><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><ul><li><p>这里<code>ALUop</code>用了4位，以便于后续添加各种类型的运算</p></li><li><p>添加零判断输出<code>isZero</code>可以在<code>beq</code>等指令中快速判断结果</p></li></ul><h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller(控制器)"></a>Controller(控制器)</h3><h4 id="输入与输出-4"><a href="#输入与输出-4" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h5><ul><li><code>opcode[5:0]</code>  </li><li><code>funct[5:0]</code></li></ul><h5 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h5><ul><li><code>RegDst</code></li><li><code>ALUSrc</code></li><li><code>MemtoReg</code></li><li><code>RegWrite</code></li><li><code>nPC_sel[1:0]</code></li><li><code>ALUctr</code></li></ul><h4 id="“与”逻辑部分"><a href="#“与”逻辑部分" class="headerlink" title="“与”逻辑部分"></a>“与”逻辑部分</h4><p>根据 <code>opcode</code> 与 <code>funct</code> 将输入的机器码识别为相应的指令：  </p><table><thead><tr><th align="center">Instruction</th><th align="center">opcode</th><th align="center">funct</th></tr></thead><tbody><tr><td align="center">add</td><td align="center">000000</td><td align="center">100000</td></tr><tr><td align="center">sub</td><td align="center">000000</td><td align="center">100010</td></tr><tr><td align="center">ori</td><td align="center">001101</td><td align="center">n/a</td></tr><tr><td align="center">lw</td><td align="center">100011</td><td align="center">n/a</td></tr><tr><td align="center">sw</td><td align="center">101011</td><td align="center">n/a</td></tr><tr><td align="center">beq</td><td align="center">000100</td><td align="center">n/a</td></tr><tr><td align="center">lui</td><td align="center">001111</td><td align="center">n/a</td></tr></tbody></table><h4 id="“或”逻辑部分"><a href="#“或”逻辑部分" class="headerlink" title="“或”逻辑部分"></a>“或”逻辑部分</h4><p>根据指令生成相应的控制信号：  </p><table><thead><tr><th align="center"></th><th align="center">add</th><th align="center">sub</th><th align="center">xor</th><th align="center">ori</th><th align="center">lw</th><th align="center">sw</th><th align="center">beq</th><th align="center">lui</th><th align="center">j</th><th align="center">jal</th><th align="center">jr</th></tr></thead><tbody><tr><td align="center"><strong>RegDst</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>ALUSrc</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>MemtoReg</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">X</td><td align="center">X</td><td align="center">0</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>RegWrite</strong></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"><strong>MemWrite</strong></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><strong>nPC_sel</strong></td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">00</td><td align="center">01</td><td align="center">00</td><td align="center">10</td><td align="center">10</td><td align="center">11</td></tr><tr><td align="center"><strong>ALUctr</strong></td><td align="center">ADD</td><td align="center">SUB</td><td align="center">XOR</td><td align="center">OR</td><td align="center">ADD</td><td align="center">ADD</td><td align="center">SUB</td><td align="center">ADD</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center"><strong>ExtOp</strong></td><td align="center">None</td><td align="center">None</td><td align="center">None</td><td align="center">Zero</td><td align="center">Sign</td><td align="center">Sign</td><td align="center">Sign</td><td align="center">High</td><td align="center">None</td><td align="center">None</td><td align="center">None</td></tr></tbody></table><h4 id="各控制信号功能"><a href="#各控制信号功能" class="headerlink" title="各控制信号功能"></a>各控制信号功能</h4><ul><li><p>RegDst：由于R型指令和I型指令所要写入的寄存器对应指令中的位数不同，需要该信号来控制写入哪个寄存器。R型指令置1（写入rd），I型指令置0（写入rt）。  </p></li><li><p>ALUSrc：选择ALU的操作数B是从寄存器中读取的还是立即数，R型指令（从寄存器中读取数）置0，I型指令（立即数）置1。  </p></li><li><p>MemtoReg：选择写入寄存器堆的值的选择信号</p><ul><li>00：运算器运算结果</li><li>01：还是存储器中取出的数</li><li>10：PC + 4</li></ul></li><li><p>RegWrite：寄存器(GRF)写使能。  </p></li><li><p>MemWrite：数据存储器(DM)写使能。  </p></li><li><p>nPC_sel：跳转信号，beq指令置01，j、jal指令置10，jr指令置11。    </p></li><li><p>ALUctr：选择需要何种运算操作（见ALU部分）。  </p></li><li><p>ExtOp：选择需要何种位扩展操作（见Ext部分）。</p></li></ul><h3 id="Ex-位扩展器"><a href="#Ex-位扩展器" class="headerlink" title="Ex(位扩展器)"></a>Ex(位扩展器)</h3><h4 id="输入与输出-5"><a href="#输入与输出-5" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h5><ul><li>16位立即数<code>Imm[15:0]</code>  </li><li>位扩展方式<code>ExtOp[1:0]</code></li></ul><h5 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h5><ul><li>位扩展结果<code>Ext[31:0]</code></li></ul><h4 id="位扩展方式"><a href="#位扩展方式" class="headerlink" title="位扩展方式"></a>位扩展方式</h4><table><thead><tr><th align="center">ExtOp</th><th align="center">Function</th></tr></thead><tbody><tr><td align="center">00</td><td align="center">Zero</td></tr><tr><td align="center">01</td><td align="center">Sign</td></tr><tr><td align="center">10</td><td align="center">High</td></tr><tr><td align="center">11</td><td align="center">?</td></tr></tbody></table><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><ul><li>这里ExtOp用两位表示，并留出一种了情况留待扩展</li></ul><h3 id="GRF-通用寄存器组"><a href="#GRF-通用寄存器组" class="headerlink" title="GRF(通用寄存器组)"></a>GRF(通用寄存器组)</h3><h4 id="输入与输出-6"><a href="#输入与输出-6" class="headerlink" title="输入与输出"></a>输入与输出</h4><h5 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h5><ul><li>读地址1<code>A1[4:0]</code>  </li><li>读地址2<code>A2[4:0]</code>  </li><li>写地址<code>A3[4:0]</code>  </li><li>数据输入<code>WD[31:0]</code></li><li>异步复位信号<code>reset</code></li><li>写使能信号<code>we</code></li></ul><h5 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h5><ul><li>输出A1指定的寄存器数据<code>RD1[31:0]</code>  </li><li>输出A2指定的寄存器数据<code>RD2[31:0]</code></li></ul><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><ul><li><p>零寄存器的值始终为0  </p></li><li><p>这里直接使用了在 <em>P0_L0_GRF</em> 中搭建的电路</p></li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>将RAM的”Data Interface”设为”Seperate load and store ports”</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><strong>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</strong></p><p>答：状态存储功能： PC 、 GRF ；状态转移功能： NPC 、 DM 。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><strong>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</strong></p><p>答：ROM是只读存储器，速度慢于RAM，但它的内容一经写入不易被更改，具有非易失性，使用于IM中可以很好地保存指令；RAM是随机存取存储器，它的速度很快，可以随时对DM中相应的地址进行读或写，用于DM中方便又快捷；Register的使用效率更高，高于RAM，将它用于GRF可以更加快捷地对32个寄存器进行读或写。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</strong></p><p>答：对于 <code>nop</code> 空指令，其对应的控制型号RegWrite、MemWrite、nPC_sel均为0，且不关心RegDst、ALUSrc、MemtoReg、ALUctr、ExtOp这些控制信号，所以无需加入控制信号真值表。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><strong>上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。</strong></p><p>在 MARS 中，默认 PC 的地址从 0x00003000 开始，所以可以在 Logisim 中的 IM 模块中判断输入是否大于 0x00003000 ，若大于，则减去 0x00003000 。</p><img src="/2023/03/21/buaa-co-2022-p3/Q4.png" class="" title="Q4"><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><strong>阅读 Pre 的 <a href="https://cscore.e1.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</strong></p><p>答：从不同指令来分析：</p><h4 id="ori指令"><a href="#ori指令" class="headerlink" title="ori指令"></a>ori指令</h4><pre class="line-numbers language-none"><code class="language-none">ori $a0, $0, 123ori $a1, $a0, 456# ori $a2, $0, -456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>包含了非零数与 0 进行或运算，非零数之间进行或运算的情况，覆盖情况很好。<del>（应该没有必要测试 0 与 0 进行或运算的情况）</del></p><h4 id="lui指令"><a href="#lui指令" class="headerlink" title="lui指令"></a>lui指令</h4><pre class="line-numbers language-none"><code class="language-none">lui $a2, 123            # 符号位为 0lui $a3, 0xffff         # 符号位为 1ori $a3, $a3, 0xffff    # $a3 = -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>未包含高位非 0 的情况。</p><h4 id="add-指令"><a href="#add-指令" class="headerlink" title="add 指令"></a>add 指令</h4><pre class="line-numbers language-none"><code class="language-none">add $s0, $a0, $a2      # 正正add $s1, $a0, $a3      # 正负add $s2, $a3, $a3      # 负负<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>包含了正数加正数，正数加负数，负数加负数三种情况。可以在此基础上测试一下数据范围边界的一些数之间的 add 。</p><h4 id="sub指令"><a href="#sub指令" class="headerlink" title="sub指令"></a>sub指令</h4><p>给出的测试样例未对 sub 指令进行测试。</p><h4 id="sw指令"><a href="#sw指令" class="headerlink" title="sw指令"></a>sw指令</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $0, 0x0000sw $a0, 0($t0)sw $a1, 4($t0)sw $a2, 8($t0)sw $a3, 12($t0)sw $s0, 16($t0)sw $s1, 20($t0)sw $s2, 24($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lw指令"><a href="#lw指令" class="headerlink" title="lw指令"></a>lw指令</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $a0, 0($t0)lw $a1, 12($t0)sw $a0, 28($t0)sw $a1, 32($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该测试一下向 $0 写入数据的情况。</p><h4 id="beq指令"><a href="#beq指令" class="headerlink" title="beq指令"></a>beq指令</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $a0, $0, 1ori $a1, $0, 2ori $a2, $0, 1beq $a0, $a1, loop1     # 不相等beq $a0, $a2, loop2     # 相等loop1:sw $a0, 36($t0)loop2:sw $a1, 40($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><h3 id="ori指令-1"><a href="#ori指令-1" class="headerlink" title="ori指令"></a>ori指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $a0, 123ori $a1, 456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="lui指令-1"><a href="#lui指令-1" class="headerlink" title="lui指令"></a>lui指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $a2, 234lui $a2, 123            # 符号位为 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add $t0, $a0, $a1       # 测试正数+正数lui $a3, 0xffff         # 符号位为 1ori $a3, $a3, 0xffff    # $a3 = -1(先构造一个负数)add $t1, $a0, $a3       # 测试正数+负数add $t2, $a3, $a3       # 测试负数+负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sub指令-1"><a href="#sub指令-1" class="headerlink" title="sub指令"></a>sub指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sub $t0, $a0, $a1       # 测试正数-正数(结果为负数)sub $t1, $a3, $a0       # 测试负数-正数sub $t2, $a3, $t0       # 测试负数-负数sub $t3, $a3, $a1       # 测试负数-正数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="xor指令"><a href="#xor指令" class="headerlink" title="xor指令"></a>xor指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">xor $t4, $a0, $a1xor $t5, $a0, $a2   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="sw指令-1"><a href="#sw指令-1" class="headerlink" title="sw指令"></a>sw指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $t0, $0, 0x0000sw $a0, 0($t0)sw $a1, 4($t0)sw $a2, 8($t0)sw $a3, 12($t0)sw $t1, 20($t0)sw $t2, 28($t0)sw $t3, 32($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lw指令-1"><a href="#lw指令-1" class="headerlink" title="lw指令"></a>lw指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $0, 0($t0)lw $a1, 0($t0)lw $a0, 8($t0)lw $a0, 12($t0)sw $a0, 24($t0)sw $a1, 28($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="beq指令-1"><a href="#beq指令-1" class="headerlink" title="beq指令"></a>beq指令</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $a0, $0, 1ori $a1, $0, 2ori $a2, $0, 1beq $a0, $a1, beq1beq $a0, $a2, beq2beq1:sw $a1, 36($t0)beq2:sw $a1, 40($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整测试样例"><a href="#完整测试样例" class="headerlink" title="完整测试样例"></a>完整测试样例</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ori $a0, 123ori $a1, 456add $t0, $a0, $a1      lui $a3, 0xffff         ori $a3, $a3, 0xffff   add $t1, $a0, $a3      add $t2, $a3, $a3       sub $t0, $a0, $a1       sub $t1, $a3, $a0      sub $t2, $a3, $t0       sub $t3, $a3, $a1  xor $t4, $a0, $a1xor $t5, $a0, $a2     ori $t0, $0, 0x0000sw $a0, 0($t0)sw $a1, 4($t0)sw $a2, 8($t0)sw $a3, 12($t0)sw $t1, 20($t0)sw $t2, 28($t0)sw $t3, 32($t0)lw $0, 0($t0)lw $a1, 0($t0)lw $a0, 8($t0)lw $a0, 12($t0)sw $a0, 24($t0)sw $a1, 28($t0)ori $a0, $0, 1ori $a1, $0, 2ori $a2, $0, 1beq $a0, $a1, beq1beq $a0, $a2, beq2beq1:sw $a1, 36($t0)beq2:sw $a1, 40($t0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2023/03/21/test1/"/>
      <url>/2023/03/21/test1/</url>
      
        <content type="html"><![CDATA[<h1 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h1><hr><p>111</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>222</p><h2 id="t3"><a href="#t3" class="headerlink" title="t3"></a>t3</h2><p>333</p><pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$ma^3b^rc^u$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/21/hello-world/"/>
      <url>/2023/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
